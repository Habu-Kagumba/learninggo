<!DOCTYPE html>
<html>
<head>
  <title></title>
  <meta name="GENERATOR" content="github.com/gomarkdown/markdown markdown processor for Go">
  <meta charset="utf-8">
  <link rel="stylesheet" type="text/css" href="inc/learninggo.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<script src="inc/prism.js">
<script src="inc/orderedlist-minimal.scale.fix.js"></script>

<script>
    $(document).ready(function() {
      $("body").wrapInner("<div class=\"book\"></div>")

      answers();
      appendices
      chapters();
      epigraphs();
      figures();
      tables();

      references();
      links();
    });

    function chapters(){
        // This is the only spot where I used knowledge of the doc, i.e.
        // Preface is the first chapter.
      $("h1:not(.appendix):not(.preface):not(.title)").each(function(index){
        $(this).prepend("Chapter " + (index+1) + ". ")
      })
    }

    function appendices(){
     $("h1.appendix").each(function(index){
        $(this).prepend("Appendix " + String.fromCharCode(65 + index) + ". ")
      })
    }

    function tables(){
      $("table > caption").each(function(index){
        $(this).prepend("Table " + (index+1) + ". ")
      })
    }

    function figures(){
      $("figure:not(.title):not(.epigraph) > figcaption").each(function(index){
        $(this).prepend("Figure " + (index+1) + ". ")
      })
    }

    function references(){
      $("a.cite").each(
        function(){
          var xid = $(this).attr("href");
          var val = $(xid).index() + 1; // 0 based
          $(this).append("[" + val + "]")
        }
      );

      $("a:empty, [href^='#']").each(
        function(){
          // Skip class=cite.
          if ($(this).hasClass("cite")) {
              return
          }
          var xid = $(this).attr("href");
          // Split out the different things we can reference.
          if ($(xid).is("table")) {
              $(this).append("Table " + ($("table").index($(xid)) + 1));
              return;
          }
          if ($(xid).is("figure")) {
              $(this).append("Figure " + ($("figure").index($(xid)) + 1));
              return;
          }
          var val = $(xid).text();
          $(this).append(val);
        }
      );
    }

    function epigraphs() {
      $("figure.epigraph figcaption").prepend("<hr>");
    }

    function links() {
        return $(":header[id]").each(function(i, el) {
            var $el, icon, id;
            $el = $(el);
            id = $el.attr('id');
            icon = '<i>&para;</i>';
            if (id) {
                return $el.prepend($("<a />").addClass("header-link").attr("href",
                        window.location.pathname + "#" + id).html(icon));
            }
        });
    }

   function answers() {
        $("h3:contains('Answer')").addClass("closed")

        $("h3:contains('Answer')").each(function() {
           $(this).click(function(){ $(this).nextUntil("h1,h2,h3").slideToggle("fast");
                $(this).toggleClass("open closed");
           });
           $(this).nextUntil("h1,h2,h3").slideUp();
        });
   }
</script>
</head>
<body>

<h1 special="preface" id="preface">Preface</h1>

<p>The <a href="https://github.com/miekg/learninggo">source of this book</a> is written in
<a href="https://github.com/mmarkdown/mmark">mmark</a> and is converted from the <a href="https://github.com/miekg/gobook">original
LaTeX source</a>.</p>

<p><em>All example code used in this book is hereby licensed under the Apache License version 2.0.</em></p>

<blockquote>
<p>This work is licensed under the Attribution-NonCommercial-ShareAlike 3.0 Unported License. To
view a copy of this license, visit <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/">http://creativecommons.org/licenses/by-nc-sa/3.0/</a>
or send a letter to Creative Commons, 171 Second Street, Suite 300, San Francisco, California, 94105, USA.</p>
</blockquote>

<p>The following people made large or small contributions to earlier versions of this book:</p>

<p>Adam J. Gray,
Alexander Katasonov,
Alexey Chernenkov,
Alex Sychev,
Andrea Spadaccini,
Andrey Mirtchovski,
Anthony Magro,
Babu Sreekanth,
Ben Bullock,
Bob Cunningham,
Brian Fallik,
Cecil New,
Cobold,
Damian Gryski,
Daniele Pala,
Dan Kortschak,
David Otton,
Fabian Becker,
Filip Zaludek,
Hadi Amiri,
Haiping Fan,
Iaroslav Tymchenko,
Jaap Akkerhuis,
JC van Winkel,
Jeroen Bulten,
Jinpu Hu,
John Shahid,
Jonathan Kans,
Joshua Stein,
Makoto Inoue,
Marco Ynema,
Mayuresh Kathe,
Mem,
Michael Stapelberg,
Nicolas Kaiser,
Olexandr Shalakhin,
Paulo Pinto,
Peter Kleiweg,
Philipp Schmidt,
Robert Johnson,
Russel Winder,
Simoc,
Sonia Keys,
Stefan Schroeder,
Thomas Kapplet,
T.J. Yang,
Uriel$<span class="math inline">\(\dagger\)</span>$,
Vrai Stacey,
Xing Xing.</p>

<p>&ldquo;Learning Go&rdquo; has been translated into (note that this used the original LaTeX source).</p>

<ul>
<li>Chinese, by Xing Xing, 这里是中文译本: <a href="http://www.mikespook.com/learning-go/">http://www.mikespook.com/learning-go/</a></li>
</ul>

<p>I hope this book is useful.</p>

<p>Miek Gieben, London, 2015.</p>

<p>This book still sees development, small incremental improvements trickle in from Github.</p>

<p>Miek Gieben, London, 2017.</p>

<p>Learning Go&rsquo;s source has been rewritten in <a href="https://github.com/mmarkdown/mmark">mmark2</a>, but did not see any
other changes.</p>

<p>Miek Gieben, London, 2018.</p>
<section matter="main">
<h1 id="learning-go" class="title">Learning Go</h1>

<!-- this .title does not work -->

<p class="title"><img src="fig/bumper-inverse.png" alt="" /></p>

<h1 id="introduction">Introduction</h1>
<figure class="epigraph">
<blockquote>
<p>Is Go an object-oriented language? Yes and no.</p>
</blockquote>
<figcaption>Frequently asked questions, Go Authors
</figcaption>
</figure>

<p>The Go programming language is an open source project language to make programmers more productive.</p>

<p>According to the website <cite class="informative"><a href="#go_web"></a></cite> &ldquo;Go is expressive, concise, clean, and efficient&rdquo;. And indeed it
is. My initial interest was piqued when I read early announcements about this new language that had
built-in concurreny and a C-like syntax (Erlang also has built-in concurrency, but I could never get
used to its syntax). Go is a compiled statically typed language that feels like a dynamically typed,
interpreted language. My go to (scripting!) language Perl has taken a back seat now that Go is
around.</p>

<p>The unique Go language is defined by these principles:</p>

<dl>
<dt>Clean and Simple</dt>
<dd>Go strives to keep things small and beautiful. You should be able to do a lot in only a few
lines of code.</dd>
<dt>Concurrent</dt>
<dd>Go makes it easy to &ldquo;fire off&rdquo; functions to be run as <em>very</em> lightweight threads. These threads
are called goroutines <span class="index" id="idxref:0"></span><sup class="footnote-ref" id="fnref:Yes-that-sounds"><a href="#fn:Yes-that-sounds">1</a></sup> in Go.</dd>
<dt>Channels</dt>
<dd>Communication with these goroutines is done, either via shared state or via <span class="index" id="idxref:1"></span>
channels <cite class="informative"><a href="#csp"></a></cite>.</dd>
<dt>Fast</dt>
<dd>Compilation is fast and execution is fast. The aim is to be as fast as C. Compilation time is
measured in seconds.</dd>
<dt>Safe</dt>
<dd>Explicit casting and strict rules when converting one type to another. Go has garbage
collection. No more <code>free()</code> in Go: the language takes care of this.</dd>
<dt>Standard format</dt>
<dd>A Go program can be formatted in (almost) any way the programmers want, but an official format
exists. The rule is very simple: The output of the filter <code>gofmt</code> <em>is the officially endorsed
format</em>.</dd>
<dt>Postfix types</dt>
<dd>Types are given <em>after</em> the variable name, thus <code>var a int</code>, instead of <code>int a</code>.</dd>
<dt>UTF-8</dt>
<dd>UTF-8 is everywhere, in strings <em>and</em> in the program code. Finally you can use $$\Phi = \Phi</dd>
<dd>1$$ in your source code.</dd>
<dt>Open Source</dt>
<dd>The Go license is completely open source.</dd>
<dt>Fun</dt>
<dd>Programming with Go should be fun!</dd>
</dl>

<p>As I mentioned Erlang also shares some features of Go. A notable difference between Erlang and Go is
that Erlang borders on being a functional language, while Go is imperative. And Erlang runs in
a virtual machine, while Go is compiled.</p>

<h2 id="how-to-read-this-book">How to Read this Book</h2>

<p>I&rsquo;ve written this book for people who already know some programming languages and how to program. In
order to use this book, you (of course) need Go installed on your system, but you can easily try
examples online in the Go playground<sup class="footnote-ref" id="fnref:http-play-golang"><a href="#fn:http-play-golang">2</a></sup>. All exercises in this book work
with Go 1, the first stable release of Go &ndash; if not, it&rsquo;s a bug.</p>

<p>The best way to learn Go is to create your own programs. Each chapter therefore includes exercises
(and answers to exercises) to acquaint you with the language. Each exercise is either <em>easy</em>,
<em>intermediate</em>, or <em>difficult</em>. The answers are included after the exercises on a new page. Some
exercises don&rsquo;t have an answer; these are marked with an asterisk.</p>

<p>Here&rsquo;s what you can expect from each chapter:</p>

<dl>
<dt><a href="#basics"></a></dt>
<dd>We&rsquo;ll look at the basic types, variables, and control structures available in the language.</dd>
<dt><a href="#functions"></a></dt>
<dd>Here we look at functions, the basic building blocks of Go programs.</dd>
<dt><a href="#packages"></a></dt>
<dd>We&rsquo;ll see that functions and data can be grouped together in packages. We&rsquo;ll also see how to
document and test our packages.</dd>
<dt><a href="#beyond-the-basics"></a></dt>
<dd>We&rsquo;ll create our own types. We&rsquo;ll also look at memory allocations in Go.</dd>
<dt><a href="#interfaces"></a></dt>
<dd>We&rsquo;ll learn how to use interfaces. Interfaces are the central concept in Go,
as Go does not support object orientation in the traditional sense.</dd>
<dt><a href="#concurrency"></a></dt>
<dd>We&rsquo;ll learn the <code>go</code> keyword, which can be used to start function in separate routines (called
goroutines). Communication with those goroutines is done via channels.</dd>
<dt><a href="#communication"></a></dt>
<dd>Finally we&rsquo;ll see how to interface with the rest of the world from within a Go program. We&rsquo;ll
see how to create files and read and write to and from them. We&rsquo;ll also briefly look into
networking.</dd>
</dl>

<h2 id="official-documentation">Official Documentation</h2>

<p>There is a substantial amount of documentation written about Go. The Go Tutorial <cite class="informative"><a href="#go_tutorial"></a></cite>, the
Go Tour (with lots of exercises) and the Effective Go <cite class="informative"><a href="#effective_go"></a></cite> are helpful resources. The
website <a href="http://golang.org/doc/">http://golang.org/doc/</a> is a very good starting point for reading up on
Go<sup class="footnote-ref" id="fnref:http-golang-org"><a href="#fn:http-golang-org">3</a></sup>. Reading these documents is certainly not
required, but it is recommended.</p>

<blockquote>
<p>When searching on the internet use the term &ldquo;golang&rdquo; instead of plain &ldquo;go&rdquo;.</p>
</blockquote>

<p>Go comes with its own documentation in the form of a program called <code>godoc</code><sup class="footnote-ref" id="fnref:When-building-fr"><a href="#fn:When-building-fr">4</a></sup>. If you are
interested in the documentation for the built-ins, simply do this:</p>

<pre><code>% godoc builtin
</code></pre>

<p>To get the documentation of the <code>hash</code> package, just:</p>

<pre><code>% godoc hash
</code></pre>

<p>To read the documentation of <code>fnv</code> contained in <code>hash</code>, you&rsquo;ll need to issue <code>godoc hash/fnv</code> as
<code>fnv</code> is a subdirectory of <code>hash</code>.</p>

<pre><code class="language-go">PACKAGE DOCUMENTATION

package fnv
    import &quot;hash/fnv&quot;

    Package fnv implements FNV-1 and FNV-1a, non-cryptographic hash
    ...
</code></pre>

<h1 id="basics">Basics</h1>
<figure class="epigraph">
<blockquote>
<p>I am interested in this and hope to do something.</p>
</blockquote>
<figcaption>On adding complex numbers to Go, Ken Thompson
</figcaption>
</figure>

<p>In this chapter we will look at the basic building blocks of the Go programming
language.</p>

<h2 id="hello-world">Hello World</h2>

<p>In the Go tutorial, you get started with Go in the typical manner: printing
&ldquo;Hello World&rdquo; (Ken Thompson and Dennis Ritchie started this when they presented
the C language in the 1970s). That&rsquo;s a great way to start, so here it is, &ldquo;Hello
World&rdquo; in Go.</p>

<pre><code class="language-go">package main <span class="callout">1</span>

import &quot;fmt&quot; <span class="callout">2</span> // Implements formatted I/O.

/* Print something */ <span class="callout">3</span>
func main() {         <span class="callout">4</span>
	fmt.Printf(&quot;Hello, world.&quot;) <span class="callout">5</span>
}
</code></pre>

<p>Lets look at the program line by line. This first line is just required <span class="callout">1</span>. All
Go files start with <code>package &lt;something&gt;</code>, and <code>package main</code> is required for
a standalone executable.</p>

<p><code>import &quot;fmt&quot;</code> says we need <code>fmt</code> in addition to <code>main</code> <span class="callout">2</span>. A package other
than <code>main</code> is commonly called a library, a familiar concept in many programming
languages (see <a href="#packages"></a>). The line ends with a comment that begins with <code>//</code>.</p>

<p>Next we another comment, but this one is enclosed in <code>/*</code> <code>*/</code> <span class="callout">3</span>. When your Go
program is executed, the first function called will be <code>main.main()</code>, which
mimics the behavior from C. Here we declare that function <span class="callout">4</span>.</p>

<p>Finally we call a function from the package <code>fmt</code> to print a string to the
screen. The string is enclosed with <code>&quot;</code> and may contain non-ASCII characters
<span class="callout">5</span>.</p>

<h2 id="compiling-and-running-code">Compiling and Running Code</h2>

<p>To build a Go program, use the <code>go</code> tool.<span class="index" id="idxref:2"></span>
To build <code>helloworld</code> we just enter:</p>

<pre><code>% go build helloworld.go
</code></pre>

<p><span class="index" id="idxref:3"></span>
This results in an executable called <code>helloworld</code>. <span class="index" id="idxref:4"></span></p>

<pre><code>% ./helloworld
Hello, world.
</code></pre>

<p>You can combine the above and just call <code>go run helloworld.go</code>.</p>

<h2 id="variables-types-and-keywords">Variables, Types and Keywords</h2>

<p>In the next few sections we will look at the variables, basic types, keywords,
and control structures of our new language.</p>

<p>Go is different from (most) other languages in that the type of a variable is
specified <em>after</em> the variable name. So not: <code>int a</code>, but <code>a int</code>. When you
declare a variable it is assigned the &ldquo;natural&rdquo; null value for the type. This
means that after <code>var a int</code>, <code>a</code> has a value of 0. With <code>var s string</code>, <code>s</code> is
assigned the zero string, which is <code>&quot;&quot;</code>. Declaring and assigning in Go is a two
step process, but they may be combined. Compare the following pieces of code
which have the same effect. <span class="index" id="idxref:5"></span> <span class="index" id="idxref:6"></span></p>

<pre><code class="language-go">var a int                           a := 15
var b bool                          b := false
a = 15
b = false
</code></pre>

<p>On the left we use the <code>var</code> keyword to declare a variable and <em>then</em> assign
a value to it. The code on the right uses <code>:=</code> to do this in one step (this form
may only be used <em>inside</em> functions). In that case the variable type is
<em>deduced</em> from the value. A value of 15 indicates an <code>int</code>. A value of <code>false</code>
tells Go that the type should be <code>bool</code>. Multiple <code>var</code> declarations may also
be grouped; <code>const</code> (see <a href="#constants"></a>) and <code>import</code> also allow this. Note the
use of parentheses instead of braces:</p>

<pre><code class="language-go">var (
    x int
    b bool
)
</code></pre>

<p>Multiple variables of the same type can also be declared on a single line: <code>var
x, y int</code> makes <code>x</code> and <code>y</code> both <code>int</code> variables. You can also make use of
<em>parallel assignment</em><span class="index" id="idxref:7"></span> <code>a, b := 20, 16</code>.
This makes <code>a</code> and <code>b</code> both integer variables and assigns
20 to <code>a</code> and 16 to <code>b</code>.</p>

<p>A special name for a variable is <code>_</code>. <span class="index" id="idxref:8"></span> Any value
assigned to it is discarded (it&rsquo;s similar to <code>/dev/null</code> on Unix). In this
example we only assign the integer value of 35 to <code>b</code> and discard the value 34:
<code>_, b := 34, 35</code>. Declared but otherwise <em>unused</em> variables are a compiler error
in Go.</p>

<h3 id="boolean-types">Boolean Types</h3>

<p>A boolean type represents the set of boolean truth values denoted by the
predeclared constants <em>true</em> and <em>false</em>. The boolean type is <code>bool</code>.</p>

<h3 id="numerical-types">Numerical Types</h3>

<p>Go has most of the well-known types such as <code>int</code>. The <code>int</code> type has the
appropriate length for your machine, meaning that on a 32-bit machine it is 32
bits and on a 64-bit machine it is 64 bits. Note: an <code>int</code> is either 32 or 64
bits, no other values are defined. Same goes for <code>uint</code>, the unsigned int.</p>

<p>If you want to be explicit about the length, you can have that too, with
<code>int32</code>, or <code>uint32</code>. The full list for (signed and unsigned) integers is
<code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code> and <code>byte</code>, <code>uint8</code>, <code>uint16</code>, <code>uint32</code>,
<code>uint64</code>, with <code>byte</code> being an alias for <code>uint8</code>. For floating point values
there is <code>float32</code> and <code>float64</code> (there is no <code>float</code> type). A 64 bit integer or
floating point value is <em>always</em> 64 bit, also on 32 bit architectures.</p>

<p>Note that these types are all distinct and assigning variables which mix these
types is a compiler error, like in the following code:</p>

<pre><code class="language-go">package main

func main() {
	var a int
	var b int32
	b = a + a
	b = b + 5
}
</code></pre>

<p>We declare two different integers, a and b where a is an <code>int</code> and b is an
<code>int32</code>. We want to set b to the sum of a and a. This fails and gives the error:
<code>cannot use a + a (type int)  as type int32 in assignment</code>. Adding the constant
5 to b <em>does</em> succeed, because constants are not typed.</p>

<h3 id="constants">Constants</h3>

<p>Constants in Go are just that &mdash; constant. They are created at compile time,
and can only be numbers, strings, or booleans; <code>const x = 42</code> makes <code>x</code>
a constant. You can use
<em>iota</em><span class="index" id="idxref:9"></span> <sup class="footnote-ref" id="fnref:The-word-iota-is"><a href="#fn:The-word-iota-is">5</a></sup> to enumerate values.</p>

<pre><code class="language-go">const (
    a = iota
    b
)
</code></pre>

<p>The first use of <code>iota</code> will yield 0, so <code>a</code> is equal to 0. Whenever <code>iota</code> is
used again on a new line its value is incremented with 1, so <code>b</code> has a value of 1.
Or, as shown here, you can even let Go repeat the use of <code>iota</code>. You may also
explicitly type a constant: <code>const b string = &quot;0&quot;</code>. Now <code>b</code> is a <code>string</code> type
constant.</p>

<h3 id="strings">Strings</h3>

<p>Another important built-in type is <code>string</code>. Assigning a string is as simple as:</p>

<pre><code class="language-go">s := &quot;Hello World!&quot;
</code></pre>

<p>Strings in Go are a sequence of UTF-8 characters enclosed in double quotes (&ldquo;).
If you use the single quote (&lsquo;) you mean one character (encoded in UTF-8) &mdash;
which is <em>not</em> a <code>string</code> in Go.</p>

<p>Once assigned to a variable, the string cannot be changed: strings in Go are
immutable. If you are coming from C, note that the following is not legal in Go:</p>

<pre><code class="language-go">var s string = &quot;hello&quot;
s[0] = 'c'
</code></pre>

<p>To do this in Go you will need the following:</p>

<pre><code class="language-go" callout="//">s := &quot;hello&quot;
c := []rune(s)	    <span class="callout">1</span>
c[0] = 'c'	        <span class="callout">2</span>
s2 := string(c)     <span class="callout">3</span>
fmt.Printf(&quot;%s\n&quot;, s2) <span class="callout">4</span>
</code></pre>

<p>Here we convert <code>s</code> to an array of runes <span class="callout">1</span>. We change the first element of
this array <span class="callout">2</span>. Then we create a <em>new</em> string <code>s2</code> with the alteration <span class="callout">3</span>.
Finally, we print the string with <code>fmt.Printf</code> <span class="callout">4</span>.</p>

<h3 id="runes">Runes</h3>

<p><code>Rune</code> is an alias for <code>int32</code>. It is an UTF-8 encoded code point. When is this
type useful? <span class="index" id="idxref:10"></span> One example is when you&rsquo;re iterating over characters in
a string. You could loop over each byte (which is only equivalent to a character
when strings are encoded in 8-bit ASCII, which they are <em>not</em> in Go!). But to
get the actual characters you should use the <code>rune</code> type.</p>

<h3 id="complex-numbers">Complex Numbers</h3>

<p>Go has native support for complex numbers. To use them you need a variable of
type <code>complex128</code> (64 bit real and imaginary parts) or <code>complex64</code> (32 bit real
and imaginary parts). Complex numbers are written as <code>re + im</code>$<span class="math inline">\(i\)</span><span class="math inline">\(, where `re`
is the real part, `im` is the imaginary part and \)</span><span class="math inline">\(i\)</span><span class="math inline">\( is the literal '\)</span><span class="math inline">\(i\)</span><span class="math inline">\('
(\)</span><span class="math inline">\(\sqrt{-1}\)</span>$).</p>

<h3 id="errors">Errors</h3>

<p>Any non-trivial program will have the need for error reporting sooner or later.
Because of this Go has a builtin type specially for errors, called <code>error</code>. <code>var
e error</code> creates a variable <code>e</code> of type <code>error</code> with the value <code>nil</code>. This error
type is an interface &ndash; we&rsquo;ll look more at interfaces in <a href="#interfaces"></a>. For
now you can just assume that <code>error</code> is a type just like all other types.</p>

<h2 id="operators-and-built-in-functions">Operators and Built-in Functions</h2>

<p>Go supports the normal set of numerical operators. See <a href="#tab-op-precedence"></a>
for lists the current ones and their relative precedence. They all associate from
left to right.</p>
<figure>
<table>
<thead>
<tr>
<th>Precedence</th>
<th>Operator(s)</th>
</tr>
</thead>

<tbody>
<tr>
<td>Highest</td>
<td>	<code>*  /  %  &lt;&lt;  &gt;&gt;  &amp;  &amp;^</code></td>
</tr>

<tr>
<td></td>
<td>	`+  -</td>
</tr>

<tr>
<td></td>
<td>	<code>==  !=  &lt;  &lt;=  &gt;  &gt;=</code></td>
</tr>

<tr>
<td></td>
<td>	<code>&lt;-</code></td>
</tr>

<tr>
<td></td>
<td>	<code>&amp;&amp;</code></td>
</tr>

<tr>
<td>Lowest</td>
<td>	||</td>
</tr>
</tbody>
</table>
<figcaption>Operator precedence.</figcaption>
</figure>

<p><code>+ - * /</code> and <code>%</code> all do what you would expect, <code>&amp; | ^</code> and <code>&amp;^</code> are bit
operators for bitwise <em>and</em><span class="index" id="idxref:11"></span> bitwise
<em>or</em><span class="index" id="idxref:12"></span> bitwise <em>xor</em><span class="index" id="idxref:13"></span> and
bit clear <span class="index" id="idxref:14"></span> respectively. The <code>&amp;&amp;</code> and <code>||</code>
operators are logical <em>and</em> <span class="index" id="idxref:15"></span> and logical <em>or</em> <span class="index" id="idxref:16"></span> Not listed in the table is the logical not <span class="index" id="idxref:17"></span> <code>!</code></p>

<p>Although Go does not support operator overloading (or method overloading for
that matter), some of the built-in operators <em>are</em> overloaded. For instance, <code>+</code>
can be used for integers, floats, complex numbers and strings (adding strings is
concatenating them).</p>

<h2 id="go-keywords">Go Keywords</h2>

<p>Let&rsquo;s start looking at keywords, <a href="#tab-keywords"></a> lists all the keywords in
Go.</p>
<figure>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>

<tbody>
<tr>
<td><code>break</code>	</td>
<td><code>default</code>	</td>
<td><code>func</code>	</td>
<td><code>interface</code></td>
<td><code>select</code></td>
</tr>

<tr>
<td><code>case</code>	</td>
<td><code>defer</code>	</td>
<td><code>go</code>	</td>
<td><code>map</code></td>
<td><code>struct</code></td>
</tr>

<tr>
<td><code>chan</code>	</td>
<td><code>else</code>	</td>
<td><code>goto</code>	</td>
<td><code>package</code></td>
<td><code>switch</code></td>
</tr>

<tr>
<td><code>const</code>	</td>
<td><code>fallthrough</code>	</td>
<td><code>if</code>	</td>
<td><code>range</code></td>
<td><code>type</code></td>
</tr>

<tr>
<td><code>continue</code>	</td>
<td><code>for</code>	</td>
<td><code>import</code>	</td>
<td><code>return</code></td>
<td><code>var</code></td>
</tr>
</tbody>
</table>
<figcaption>Keywords in Go.</figcaption>
</figure>

<p>We&rsquo;ve seen some of these already. We used <code>var</code> and <code>const</code> in the <a href="#variables-types-and-keywords"></a>
section,  and we briefly looked at <code>package</code> and <code>import</code> in our &ldquo;Hello World&rdquo;
program at the start of the chapter. Others need more attention and have their
own chapter or section:</p>

<ul>
<li><code>func</code> is used to declare functions and methods.</li>
<li><code>return</code> is used to return from functions. We&rsquo;ll look at both <code>func</code> and <code>return</code> in detail in <a href="#functions"></a>.</li>
<li><code>go</code> is used for concurrency. We&rsquo;ll look at this in <a href="#channels"></a>.</li>
<li><code>select</code> used to choose from different types of communication, We&rsquo;ll work with <code>select</code> in <a href="#channels"></a>.</li>
<li><code>interface</code> is covered in <a href="#interfaces"></a>.</li>
<li><code>struct</code> is used for abstract data types. We&rsquo;ll work with <code>struct</code> in <a href="#beyond-the-basics"></a>.</li>
<li><code>type</code> is also covered in <a href="#beyond-the-basics"></a>.</li>
</ul>

<h2 id="control-structures">Control Structures</h2>

<p>There are only a few control structures in Go. To write loops we use the <code>for</code>
keyword, and there is a <code>switch</code> and of course an <code>if</code>. When working with
channels <code>select</code> will be used (see <a href="#channels"></a>). Parentheses are are not
required around the condition, and the body must <em>always</em> be brace-delimited.</p>

<h3 id="if-else">If-Else</h3>

<p>In Go an <code>if</code> <span class="index" id="idxref:18"></span> looks like this:</p>

<pre><code class="language-go">if x &gt; 0 {
    return y
} else {
    return x
}
</code></pre>

<p><span class="index" id="idxref:19"></span> <span class="index" id="idxref:20"></span> Since <code>if</code> and <code>switch</code> accept an
initialization statement, it&rsquo;s common to see one used to set up a (local)
variable.</p>

<pre><code class="language-go">if err := SomeFunction(); err == nil {
    // do something
} else {
    return err
}
</code></pre>

<p>It is idomatic in Go to omit the <code>else</code> when the <code>if</code> statement&rsquo;s body has
a <code>break</code>, <code>continue</code>, <code>return</code> or, <code>goto</code>, so the above code would be better
written as:</p>

<pre><code class="language-go">if err := SomeFunction(); err != nil {
    return err
}
// do something
</code></pre>

<p>The opening brace on the first line must be positioned on the same line as the
<code>if</code> statement. There is no arguing about this, because this is what <code>gofmt</code>
outputs.</p>

<h3 id="goto">Goto</h3>

<p>Go has a <code>goto</code> <span class="index" id="idxref:21"></span> statement - use it wisely. With <code>goto</code> you
jump to a <span class="index" id="idxref:22"></span> label which must be defined within the current function.
For instance, a loop in disguise:</p>

<pre><code class="language-go">func myfunc() {
    i := 0
Here:
    fmt.Println(i)
    i++
    goto Here
}
</code></pre>

<p>The string <code>Here:</code> indicates a label. A label does not need to start with
a capital letter and is case sensitive.</p>

<h3 id="for">For</h3>

<p>The Go <code>for</code> <span class="index" id="idxref:23"></span> loop has three forms, only one of which has
semicolons:</p>

<ul>
<li><code>for init; condition; post { }</code> - a loop using the syntax borrowed from C;</li>
<li><code>for condition { }</code> - a while loop, and;</li>
<li><code>for { }</code> - an endless loop.</li>
</ul>

<p>Short declarations make it easy to declare the index variable right in the loop.</p>

<pre><code class="language-go">sum := 0
for i := 0; i &lt; 10; i++ {
    sum = sum + i
}
</code></pre>

<p>Note that the variable <code>i</code> ceases to exist after the loop.</p>

<h3 id="break-and-continue">Break and Continue</h3>

<p>With <code>break</code> <span class="index" id="idxref:24"></span> you can quit loops early.  By itself, <code>break</code>
breaks the current loop.</p>

<pre><code class="language-go" callout="//">for i := 0; i &lt; 10; i++ {
    if i &gt; 5 {
    break <span class="callout">1</span>
    }
    fmt.Println(i) <span class="callout">2</span>
}
</code></pre>

<p>Here we <code>break</code> the current loop <span class="callout">1</span>, and don&rsquo;t continue with the
<code>fmt.Println(i)</code> statement <span class="callout">2</span>. So we only print 0 to 5. With loops within loop
you can specify a label after <code>break</code> to identify <em>which</em> loop to stop:</p>

<pre><code class="language-go" callout="//">J:  for j := 0; j &lt; 5; j++ { <span class="callout">1</span>
        for i := 0; i &lt; 10; i++ {
            if i &gt; 5 {
                break J <span class="callout">2</span>
            }
            fmt.Println(i)
        }
    }
</code></pre>

<p>Here we define a label &ldquo;J&rdquo; <span class="callout">1</span>, preceding the <code>for</code>-loop there. When we use
<code>break J</code> <span class="callout">2</span>, we don&rsquo;t break the inner loop but the &ldquo;J&rdquo; loop.</p>

<p>With <code>continue</code> <span class="index" id="idxref:25"></span> you begin the next iteration of the
loop, skipping any remaining code. In the same way as <code>break</code>, <code>continue</code> also
accepts a label.</p>

<h3 id="range">Range</h3>

<p>The keyword <code>range</code> <span class="index" id="idxref:26"></span> can be used for loops. It can loop
over slices, arrays, strings, maps and channels (see <a href="#channels"></a>). <code>range</code> is an
iterator that, when called, returns the next key-value pair from the &ldquo;thing&rdquo; it
loops over. Depending on what that is, <code>range</code> returns different things.</p>

<p>When looping over a slice or array, <code>range</code> returns the index in the slice as
the key and value belonging to that index. Consider this code: <span class="index" id="idxref:27"></span></p>

<pre><code class="language-go">list := []string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;}
for k, v := range list {
    // do something with k and v
}
</code></pre>

<p>First we create a slice of strings. Then we use <code>range</code> to loop over them. With
each iteration, <code>range</code> will return the index as an <code>int</code> and the key as
a <code>string</code>. It will start with 0 and &ldquo;a&rdquo;, so <code>k</code> will be 0 through 5, and v will
be &ldquo;a&rdquo; through &ldquo;f&rdquo;.</p>

<p>You can also use <code>range</code> on strings directly. Then it will break out the
individual Unicode characters ^[In the UTF-8 world characters are sometimes
called <em>runes</em> <span class="index" id="idxref:28"></span> Mostly, when people talk about characters, they
mean 8 bit characters. As UTF-8 characters may be up to 32 bits the word rune is
used. In this case the type of <code>char</code> is <code>rune</code>. and their start position, by
parsing the UTF-8. The loop: <span class="index" id="idxref:29"></span></p>

<pre><code class="language-go">for pos, char := range &quot;Gő!&quot; {
    fmt.Printf(&quot;character '%c' starts at byte position %d\n&quot;, char, pos)
}
</code></pre>

<p>prints</p>

<pre><code>character 'G' starts at byte position 0
character 'ő' starts at byte position 1
character '!' starts at byte position 3
</code></pre>

<p>Note that <code>ő</code> took 2 bytes, so &lsquo;!&rsquo; starts at byte 3.</p>

<h3 id="switch">Switch</h3>

<p>Go&rsquo;s <code>switch</code> <span class="index" id="idxref:30"></span> is very flexible; you can match on much
more than just integers. The cases are evaluated top to bottom until a match is
found, and if the <code>switch</code> has no expression it switches on <code>true</code>. It&rsquo;s
therefore possible &ndash; and idiomatic &ndash; to write an <code>if-else-if-else</code> chain as
a <code>switch</code>.</p>

<pre><code class="language-go">// Convert hexadecimal character to an int value
switch { <span class="callout">1</span>
case '0' &lt;= c &amp;&amp; c &lt;= '9': <span class="callout">2</span>
    return c - '0' <span class="callout">3</span>
case 'a' &lt;= c &amp;&amp; c &lt;= 'f': <span class="callout">4</span>
    return c - 'a' + 10
case 'A' &lt;= c &amp;&amp; c &lt;= 'F': <span class="callout">5</span>
    return c - 'A' + 10
}
return 0
</code></pre>

<p>A <code>switch</code> without a condition is the same as <code>switch true</code> <span class="callout">1</span>. We list the
different cases. Each <code>case</code> statement has a condition that is either true of
false. Here <span class="callout">2</span> we check if <code>c</code> is a number. If <code>c</code> is a number we return its
value <span class="callout">3</span>. Check if <code>c</code> falls between &ldquo;a&rdquo; and &ldquo;f&rdquo; <span class="callout">4</span>. For an &ldquo;a&rdquo; we
return 10, for &ldquo;b&rdquo; we return 11, etc. We also do the same <span class="callout">5</span> thing for &ldquo;A&rdquo;
to &ldquo;F&rdquo;.</p>

<p>There is no automatic fall through, you can use <code>fallthrough</code> <span class="index" id="idxref:31"></span> for that.</p>

<pre><code class="language-go" callout="//">switch i {
    case 0:  fallthrough
    case 1: <span class="callout">1</span>
        f()
    default:
        g() <span class="callout">2</span>
</code></pre>

<p><code>f()</code> can be called when <code>i == 0</code> <span class="callout">1</span>. With <code>default</code> <span class="index" id="idxref:32"></span> you
can specify an action when none of the other cases match. Here <code>g()</code> is called
when <code>i</code> is not 0 or 1 <span class="callout">2</span>. We could rewrite the above example as:</p>

<pre><code class="language-go" callout="//">switch i {
    case 0, 1: <span class="callout">1</span>
        f()
    default:
        g()
</code></pre>

<p>You can list cases on one line <span class="callout">1</span>, separated by commas.</p>

<h2 id="built-in-functions">Built-in Functions</h2>

<p>A few functions are predefined, meaning you <em>don&rsquo;t</em> have to include any package
to get access to them. <a href="#tab-predef-functions"></a> lists them all.<sup class="footnote-ref" id="fnref:You-can-use-the"><a href="#fn:You-can-use-the">6</a></sup></p>
<figure>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>

<tbody>
<tr>
<td><code>close</code></td>
<td><code>new</code></td>
<td><code>panic</code></td>
<td><code>complex</code></td>
</tr>

<tr>
<td><code>delete</code></td>
<td><code>make</code></td>
<td><code>recover</code></td>
<td><code>real</code></td>
</tr>

<tr>
<td><code>len</code></td>
<td><code>append</code></td>
<td><code>print</code></td>
<td><code>imag</code></td>
</tr>

<tr>
<td><code>cap</code></td>
<td><code>copy</code></td>
<td><code>println</code></td>
<td></td>
</tr>
</tbody>
</table>
<figcaption>Pre-defined functions in Go.</figcaption>
</figure>

<p>These built-in functions are documented in the <code>builtin</code> <span class="index" id="idxref:33"></span>
pseudo package that is included in recent Go releases. Let&rsquo;s go over these
functions briefly.</p>

<dl>
<dt><code>close</code></dt>
<dd>is used in channel communication. It closes a channel. We&rsquo;ll learn more about this in <a href="#channels"></a>.
<span class="index" id="idxref:34"></span></dd>
<dt><code>delete</code></dt>
<dd>is used for deleting entries in maps. <span class="index" id="idxref:35"></span></dd>
<dt><code>len</code> and <code>cap</code></dt>
<dd>are used on a number of different types, <code>len</code> is
used to return the lengths of strings, slices, and
arrays. In the next section <a href="#arrays"></a> we&rsquo;ll look at slices,
arrays and the function <code>cap</code>.<span class="index" id="idxref:36"></span><span class="index" id="idxref:37"></span></dd>
<dt><code>new</code></dt>
<dd>is used for allocating memory for user defined
data types. See <a href="#allocation-with-new"></a>.
<span class="index" id="idxref:38"></span></dd>
<dt><code>make</code></dt>
<dd>is used for allocating memory for built-in
types (maps, slices, and channels). See <a href="#allocation-with-make"></a>.
<span class="index" id="idxref:39"></span></dd>
<dt><code>copy</code>, <code>append</code></dt>
<dd><code>copy</code> is for copying slices. <span class="index" id="idxref:40"></span>
And <code>append</code> is for concatenating slices. See <a href="#slices"></a> in this chapter. <span class="index" id="idxref:41"></span></dd>
<dt><code>panic</code>, <code>recover</code></dt>
<dd>are used for an <em>exception</em> mechanism. See <a href="#panic-and-recovering"></a> for more.
<span class="index" id="idxref:42"></span>
<span class="index" id="idxref:43"></span></dd>
<dt><code>print</code>, <code>println</code></dt>
<dd>are low level printing functions that can be used without reverting to the
<code>fmt</code> <span class="index" id="idxref:44"></span> package. These are mainly used for debugging.
<span class="index" id="idxref:45"></span>built-in,println)</dd>
<dt><code>complex</code>, <code>real</code>, <code>imag</code></dt>
<dd>all deal with complex numbers. <span class="index" id="idxref:46"></span> We will not use complex numbers in this book.
<span class="index" id="idxref:47"></span>
<span class="index" id="idxref:48"></span>
<span class="index" id="idxref:49"></span></dd>
</dl>

<h2 id="arrays-slices-and-maps">Arrays, Slices, and Maps</h2>

<p>To store multiple values in a list, you can use arrays, or their more flexible
cousin: slices. A dictionary or hash type is also available. It is called
a <code>map</code> in Go.</p>

<h3 id="arrays">Arrays</h3>

<p>An array is defined by: <code>[n]&lt;type&gt;</code>, where $<span class="math inline">\(n\)</span>$ is the length of the array and
<code>&lt;type&gt;</code> is the stuff you want to store. To assign or index an element in the
array, you use square brackets:</p>

<pre><code class="language-go">var arr [10]int
arr[0] = 42
arr[1] = 13
fmt.Printf(&quot;The first element is %d\n&quot;, arr[0])
</code></pre>

<p>Array types like <code>var arr [10]int</code> have a fixed size. The size is <em>part</em> of the
type. They can&rsquo;t grow, because then they would have a different type. Also
arrays are values: Assigning one array to another <em>copies</em> all the elements. In
particular, if you pass an array to a function it will receive a copy of the
array, not a pointer to it.</p>

<p><span class="index" id="idxref:50"></span> To declare an array you can use the following: <code>var
a [3]int</code>. To initialize it to something other than zero, use a
<em>composite literal</em> <span class="index" id="idxref:51"></span> <code>a := [3]int{1, 2, 3}</code>. This can
 be shortened to <code>a := [...]int{1, 2, 3}</code>, where Go counts the elements
 automatically.</p>

<aside>
<p>A composite literal allows you
to assign a value directly to an array, slice, or map.
See <a href="#constructors-and-composite-literals"></a> for more information.</p>
</aside>

<p>When declaring arrays you <em>always</em> have to type something in between the square
brackets, either a number or three dots (<code>...</code>), when using a composite literal.
When using multidimensional arrays, you can use the following syntax: <code>a :=
[2][2]int{ {1,2}, {3,4} }</code>. Now that you know about arrays you will be delighted
to learn that you will almost never use them in Go, because there is something
much more flexible: slices.</p>

<h3 id="slices">Slices</h3>

<p>A slice is similar to an array, but it can grow when new elements are added.
A slice always refers to an underlying array. What makes slices different from
arrays is that a slice is a pointer <em>to</em> an array; slices are reference
types.<span class="index" id="idxref:52"></span></p>

<aside>
<p>Reference types are created with <code>make</code>. We detail this further
in <a href="#beyond-the-basics"></a>.</p>
</aside>

<p>That means that if you assign one slice to another, both refer to the <em>same</em>
underlying array. For instance, if a function takes a slice argument, changes it
makes to the elements of the slice will be visible to the caller, analogous to
passing a pointer to the underlying array. With: <code>slice := make([]int, 10)</code>, you
create a slice which can hold ten elements. Note that the underlying array isn&rsquo;t
specified. A slice is always coupled to an array that has a fixed size. For
slices we define a capacity <span class="index" id="idxref:53"></span> and a length
<span class="index" id="idxref:54"></span> <a href="#fig-array-vs-slice"></a> shows the creation of an array,
then the creation of a slice. First we create an array of $<span class="math inline">\(m\)</span>$ elements of the
type <code>int</code>: <code>var array[m]int</code> .</p>

<p>Next, we create a slice from this array: <code>slice := array[:n]</code> . And now we have:</p>

<ul>
<li><code>len(slice) == n</code></li>
<li><code>cap(slice) == m</code></li>
<li><code>len(array) == cap(array) == m</code></li>
</ul>

<p id="fig-array-vs-slice"><img src="fig/array-vs-slice.png" alt="Array versus slice" title="An array versus a slice." /></p>

<p>Given an array, or another slice, a new slice is created via <code>a[n:m]</code>. This
creates a new slice which refers to the variable <code>a</code>, starts at index <code>n</code>, and
ends before index <code>m</code>. It has length <code>n - m</code>.</p>

<pre><code class="language-go">a := [...]int{1, 2, 3, 4, 5} <span class="callout">1</span>
s1 := a[2:4] <span class="callout">2</span>
s2 := a[1:5] <span class="callout">3</span>
s3 := a[:]   <span class="callout">4</span>
s4 := a[:4]  <span class="callout">5</span>
s5 := s2[:] <span class="callout">6</span>
s6 := a[2:4:5] <span class="callout">7</span>
</code></pre>

<!-- Double check this -->

<p>First we define <span class="callout">1</span> an array with five elements, from index 0 to 4.
From this we create <span class="callout">2</span> a slice with the elements from index 2 to 3, this slices contains: <code>3, 4</code>.
Then we we create another slice <span class="callout">3</span> from <code>a</code>: with the elements from index 1 to 4,
this contains: <code>2, 3, 4, 5</code>.
With <code>a[:]</code> <span class="callout">4</span> we create a slice with all the elements in the array. This is a shorthand for: <code>a[0:len(a)]</code>.
And with <code>a[:4]</code> <span class="callout">5</span> we create a slice with the elements from index
0 to 3, this is short for: <code>a[0:4]</code>, and gives us a slices that contains: <code>1, 2, 3, 4</code>.
With <code>s2[:]</code> we create a slice from the slice <code>s2</code> <span class="callout">6</span>, note that <code>s5</code> still refers to the array <code>a</code>.
Finally, we create a slice with the elements from index 3 to 3 <em>and</em> also set the cap to 4 <span class="callout">7</span>.</p>

<p>When working with slices you can overrun the bounds, consider this code.</p>

<pre><code class="language-go">package main

func main() {
	var array [100]int   <span class="callout">1</span>
	slice := array[0:99] <span class="callout">2</span>

	slice[98] = 1 <span class="callout">3</span>
	slice[99] = 2 <span class="callout">4</span>
}
</code></pre>

<p>At <span class="callout">1</span> we create an array with a 100 elements, indexed from 0 to 99. Then at <span class="callout">2</span>
we create a slice that has index 0 to 98. We assign 1 to the 99th element <span class="callout">3</span> of
the slice. This works as expected. But at <span class="callout">4</span> we dare to do the impossible, and
and try to allocate something beyond the length of the slice and we are greeted
with a <em>runtime</em> error: <code>Error: &quot;throw: index out of range&quot;.</code></p>

<p>If you want to extend a slice, there are a couple of built-in functions that
make life easier: <code>append</code> and <code>copy</code>. The append function appends zero or more
values to a slice and returns the result: a slice with the same type as the
original. If the original slice isn&rsquo;t big enough to fit the added values, append
will allocate a new slice that is big enough. So the slice returned by append
may refer to a different underlying array than the original slice does. Here&rsquo;s
an example: <span class="index" id="idxref:55"></span></p>

<pre><code class="language-go">s0 := []int{0, 0}
s1 := append(s0, 2) <span class="callout">1</span>
s2 := append(s1, 3, 5, 7) <span class="callout">2</span>
s3 := append(s2, s0...) <span class="callout">3</span>
</code></pre>

<p>At <span class="callout">1</span> we append a single element, making <code>s1</code> equal to <code>[]int{0, 0, 2}</code>. At <span class="callout">2</span>
we append multiple elements, making <code>s2</code> equal to <code>[]int{0, 0, 2, 3, 5, 7}</code>. And
at <span class="callout">3</span> we append a slice, giving us <code>s3</code> equal to <code>[]int{0, 0, 2, 3, 5, 7, 0, 0}</code>.
Note the three dots used after <code>s0...</code>! This is needed make it clear
  explicit that you&rsquo;re appending another slice, instead of a single value.</p>

<p>The copy function copies slice elements from a source to a destination, and
returns the number of elements it copied. This number is the minimum of the
length of the source and the length of the destination. For example:
<span class="index" id="idxref:56"></span></p>

<pre><code class="language-go">var a = [...]int{0, 1, 2, 3, 4, 5, 6, 7}
var s = make([]int, 6)
n1 := copy(s, a[0:]) <span class="callout">1</span>
n2 := copy(s, s[2:]) <span class="callout">2</span>
</code></pre>

<p>After <span class="callout">1</span>, <code>n1</code> is 6, and <code>s</code> is <code>[]int{0, 1, 2, 3, 4, 5}</code>.
And after <span class="callout">2</span>, <code>n2</code> is 4, and <code>s</code> is <code>[]int{2, 3, 4, 5, 4, 5}</code>.</p>

<h3 id="maps">Maps</h3>

<p>Many other languages have a type similar to maps built-in. For instance, Perl
has hashes, Python has its dictionaries, and C++ also has maps (as part of the
libraries). In Go we have the <code>map</code> <span class="index" id="idxref:57"></span> type. A <code>map</code> can be
thought of as an array indexed by strings (in its most simple form).</p>

<pre><code class="language-go">monthdays := map[string]int{
    &quot;Jan&quot;: 31, &quot;Feb&quot;: 28, &quot;Mar&quot;: 31,
    &quot;Apr&quot;: 30, &quot;May&quot;: 31, &quot;Jun&quot;: 30,
    &quot;Jul&quot;: 31, &quot;Aug&quot;: 31, &quot;Sep&quot;: 30,
    &quot;Oct&quot;: 31, &quot;Nov&quot;: 30, &quot;Dec&quot;: 31, <span class="callout">1</span>
}
</code></pre>

<p>The general syntax for defining a map is <code>map[&lt;from type&gt;]&lt;to type&gt;</code>. Here, we
define a map that converts from a <code>string</code> (month abbreviation) to an <code>int</code>
(number of days in that month). Note that the trailing comma at <span class="callout">1</span> is
<em>required</em>.</p>

<p>Use <code>make</code> when only declaring a map: <code>monthdays := make(map[string]int)</code>. A map
is a reference type.</p>

<p>For indexing (&ldquo;searching&rdquo;) the map, we use square brackets. For example, suppose
we want to print the number of days in December: <code>fmt.Printf(&quot;%d\n&quot;,
monthdays[&quot;Dec&quot;])</code></p>

<p>If you are looping over an array, slice, string, or map a, <code>range</code> <span class="index" id="idxref:58"></span> clause will help you again, it returns the key and corresponding value
with each invocation.</p>

<pre><code class="language-go">year := 0
for _, days := range monthdays <span class="callout">1</span>
    year += days
}
fmt.Printf(&quot;Numbers of days in a year: %d\n&quot;, year)
</code></pre>

<p>At <span class="callout">1</span> we use the underscore to ignore (assign to nothing) the key returned by
<code>range</code>. We are only interested in the values from <code>monthdays</code>.</p>

<p><span class="index" id="idxref:59"></span></p>

<p>To add elements to the map, you would add new month with: <code>monthdays[&quot;Undecim&quot;]
= 30</code>. If you use a key that already exists, the value will be silently
overwritten: <code>monthdays[&quot;Feb&quot;] = 29</code>. To test for existence <span class="index" id="idxref:60"></span> you would use the following: <code>value, present := monthdays[&quot;Jan&quot;]</code>.
If the key &ldquo;Jan&rdquo; exists, <code>present</code> will be true. It&rsquo;s more Go like to name
<code>present</code> &ldquo;ok&rdquo;, and use: <code>v, ok := monthdays[&quot;Jan&quot;]</code>. In Go we call this the
&ldquo;comma ok&rdquo; form.</p>

<p>You can remove elements <span class="index" id="idxref:61"></span> from the <code>map</code>:
<code>delete(monthdays, &quot;Mar&quot;)</code> <sup class="footnote-ref" id="fnref:Always-rainy-in"><a href="#fn:Always-rainy-in">7</a></sup>. In general the
syntax <code>delete(m, x)</code> will delete the map entry retrieved by the expression
<code>m[x]</code>.</p>

<h2 id="exercises">Exercises</h2>

<h3 id="for-loop" class="exersice" data-difficulty="0">For-loop</h3>

<ol>
<li><p>Create a loop with the <code>for</code> construct. Make it loop
10 times and print out the loop counter with the <code>fmt</code> package.</p></li>

<li><p>Rewrite the loop from 1 to use <code>goto</code>. The keyword <code>for</code> may not be used.</p></li>

<li><p>Rewrite the loop again so that it fills an array and then prints that array to the screen.</p></li>
</ol>

<h3 id="answer" class="answer">Answer</h3>

<ol>
<li>There are many possibilities. One solution could be:</li>
</ol>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	for i := 0; i &lt; 10; i++ {
		fmt.Println(&quot;%d&quot;, i)
	}
}
</code></pre>

<p>Let&rsquo;s compile this and look at the output.</p>

<pre><code>    % go build for.go
    % ./for
    0
    1
    .
    .
    .
    9
</code></pre>

<ol start="2">
<li><p>Rewriting the loop results in code that should look something
like this (only showing the <code>main</code>-function):</p>

<pre><code class="language-go">func main() {
    i := 0	<span class="callout">1</span>
Loop:		    <span class="callout">2</span>
    if i &lt; 10 {
        fmt.Printf(&quot;%d\n&quot;, i)
        i++
        goto Loop <span class="callout">3</span>
    }
}
</code></pre>
<p>At <span class="callout">1</span> we define our loop variable. And at <span class="callout">2</span> we define a label and at <span class="callout">3</span> we jump
to this label.</p></li>

<li><p>The following is one possible solution:
&lt;{{src/for-arr.go}}</p>

<p>Here <span class="callout">1</span> we create an array with 10 elements.
Which we then fill <span class="callout">2</span> one by one. And finally we print it <span class="callout">3</span> with <code>%v</code> which lets
Go to print the value for us. You could even do this in one fell swoop by using a composite literal:</p></li>
</ol>

<pre><code class="language-go">fmt.Printf(&quot;%v\n&quot;, [...]int{0,1,2,3,4,5,6,7,8,9})
</code></pre>

<h3 id="average" class="exercise" data-difficulty="1">Average</h3>

<ol>
<li>Write code to calculate the average of a <code>float64</code> slice. In
a later exercise you will make it into a function.</li>
</ol>

<h3 id="answer-1" class="answer">Answer</h3>

<ol>
<li>The following code calculates the average.</li>
</ol>

<pre><code class="language-go">sum := 0.0
switch len(xs) {
case 0: <span class="callout">1</span>
    avg = 0
default: <span class="callout">2</span>
    for _, v := range xs {
        sum += v
    }
    avg = sum / float64(len(xs)) <span class="callout">3</span>
}
</code></pre>

<p>Here at <span class="callout">1</span> we check if the length is zero and if so, we return 0.
Otherwise we calculate the average at <span class="callout">2</span>.
We have to convert the value return from <code>len</code> to a <code>float64</code>
to make the division work at <span class="callout">3</span>.</p>

<h3 id="fizzbuzz" class="exercise" data-difficulty="0">FizzBuzz</h3>

<ol>
<li>Solve this problem, called the Fizz-Buzz <cite class="informative"><a href="#fizzbuzz"></a></cite> problem:</li>
</ol>

<p>Write a program that prints the numbers from 1 to 100. But for multiples
of three print, &ldquo;Fizz&rdquo; instead of the number, and for multiples of
five, print &ldquo;Buzz&rdquo;. For numbers which are multiples of both three and
five, print &ldquo;FizzBuzz&rdquo;.</p>

<h3 id="answer-2" class="answer">Answer</h3>

<ol>
<li>A possible solution to this problem is the following program.</li>
</ol>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	const (
		FIZZ = 3 <span class="callout">1</span>
		BUZZ = 5
	)
	var p bool                 <span class="callout">2</span>
	for i := 1; i &lt; 100; i++ { <span class="callout">3</span>
		p = false
		if i%FIZZ == 0 { <span class="callout">4</span>
			fmt.Printf(&quot;Fizz&quot;)
			p = true
		}
		if i%BUZZ == 0 { <span class="callout">5</span>
			fmt.Printf(&quot;Buzz&quot;)
			p = true
		}
		if !p { <span class="callout">6</span>
			fmt.Printf(&quot;%v&quot;, i)
		}
		fmt.Println()
	}
}
</code></pre>

<p>Here <span class="callout">1</span> we define two constants to make our code more readable, see <a href="#constants"></a>.
At <span class="callout">2</span> we define a boolean that keeps track if we already printed something.
At <span class="callout">3</span> we start our for-loop, see <a href="#for"></a>.
If the value is divisible by FIZZ - that is, 3 - , we print &ldquo;Fizz&rdquo; <span class="callout">4</span>.
And at <span class="callout">5</span> we check if the value is divisble by BUZZ &ndash; that is, 5 &ndash; if so print
&ldquo;Buzz&rdquo;. Note that we have also taken care of the FizzBuzz case.
At <span class="callout">6</span>, if printed neither Fizz nor Buzz printed, we print the value.</p>

<h1 id="functions">Functions</h1>
<figure class="epigraph">
<blockquote>
<p>I&rsquo;m always delighted by the light touch and stillness of
early programming languages.  Not much text; a lot gets
done. Old programs read like quiet conversations
between a well-spoken research worker and a well-
studied mechanical colleague, not as a debate with a
compiler.  Who&rsquo;d have guessed sophistication bought
such noise?</p>
</blockquote>
<figcaption>Richard P. Gabriel
</figcaption>
</figure>

<p>Functions are the basic building blocks of Go programs; all interesting stuff
happens in them.</p>

<p>Here is an example of how you can declare a function:</p>

<pre><code class="language-go">type mytype int
func (p mytype) funcname(q int) (r,s int) { return 0,0 }
<span class="callout">1</span>        <span class="callout">2</span>        <span class="callout">3</span>      <span class="callout">4</span>        <span class="callout">5</span>         <span class="callout">6</span>
</code></pre>

<p>To declare a function, you use the <code>func</code> keyword <span class="callout">1</span>. You can optionally bind
<span class="callout">2</span> to a specific type called receiver <span class="index" id="idxref:62"></span> (a function
with a receiver is usually called a method<span class="index" id="idxref:63"></span>). This will
be explored in <a href="#interfaces"></a>. Next <span class="callout">3</span> you write the name of your
function. Here <span class="callout">4</span> we define that the variable <code>q</code> of type <code>int</code> is the input
parameter. Parameters are passed <em>pass-by-value</em>.<span class="index" id="idxref:64"></span>
The variables <code>r</code> and <code>s</code> <span class="callout">5</span> are the <em>named return parameters</em> (((functions,
named return parameters))) for this function. Functions in Go can have multiple
return values. This is very useful to return a value <em>and</em> error. This
removes the need for in-band error returns (such as -1 for <code>EOF</code>) and modifying
an argument. If you want the return parameters not to be named you only give the
types: <code>(int, int)</code>. If you have only one value to return you may omit the
parentheses. If your function is a subroutine and does not have anything to
return you may omit this entirely. Finally, we have the body <span class="callout">6</span> of the
function. Note that <code>return</code> is a statement so the braces around the
parameter(s) are optional.</p>

<p>As said the return or result parameters of a Go function can be given names and
used as regular variables, just like the incoming parameters. When named, they
are initialized to the zero values for their types when the function begins. If
the function executes a <code>return</code> statement with no arguments, the current values
of the result parameters are returned. Using these features enables you (again)
to do more with less code.<sup class="footnote-ref" id="fnref:This-is-a-motto"><a href="#fn:This-is-a-motto">8</a></sup></p>

<p>The names are not mandatory but they can make code shorter and clearer:
<em>they are documentation</em>. However don&rsquo;t overuse this feature, especially in
 longer functions where it might not be immediately apparent what is returned.</p>

<p>Functions can be declared in any order you wish. The compiler scans the entire
file before execution, so function prototyping is a thing of the past in Go. Go
does not allow nested functions, but you can work around this with anonymous
functions. See the Section <a href="#functions-as-values"></a> in this chapter. Recursive
functions work just as in other languages:</p>

<pre><code class="language-go">func rec(i int) {
    if i == 10 { <span class="callout">1</span>
        return
    }
    rec(i+1) <span class="callout">2</span>
    fmt.Printf(&quot;%d &quot;, i)
}
</code></pre>

<p>Here <span class="callout">2</span> we call the same function again, <code>rec</code> returns when <code>i</code> has the value
10, this is checked on the second line <span class="callout">1</span>. This function prints: <code>9
8 7 6 5 4 3 2 1 0</code>, when called as <code>rec(0)</code>.</p>

<h2 id="scope">Scope</h2>

<p>Variables declared outside any functions are <em>global</em> <span class="index" id="idxref:65"></span> in Go,
those defined in functions are <em>local</em> <span class="index" id="idxref:66"></span> to those functions. If
names overlap - a local variable is declared with the same name as a global one
- the local variable hides the global one when the current function is executed.</p>

<p>In the following example we call <code>g()</code> from <code>f()</code>:</p>

<pre><code class="language-go">package main

var a int <span class="callout">1</span>

func main() {
    a = 5
    print(a)
    f()
}

func f() {
    a := 6 <span class="callout">2</span>
    print(a)
    g()
}

func g() {
    print(a)
}
</code></pre>

<p>Here <span class="callout">1</span>, we declare <code>a</code> to be a global variable of type <code>int</code>. Then in the
<code>main</code> function we give the <em>global</em> <code>a</code> the value of 5, after printing it we
call the function <code>f</code>. Then here <span class="callout">2</span>, <code>a := 6</code>, we create a <em>new, local</em>
variable also called <code>a</code>. This new <code>a</code> gets the value of 6, which we then print.
Then we call <code>g</code>, which uses the <em>global</em> <code>a</code> again and prints <code>a</code>&rsquo;s value set
in <code>main</code>. Thus the output will be: <code>565</code>. A <em>local</em> variable is <em>only</em> valid
when we are executing the function in which it is defined. Note that the <code>:=</code>
used in line 12 is sometimes hard to spot so it is generally advised <em>not</em> to
use the same name for global and local variables.</p>

<h2 id="functions-as-values">Functions as values</h2>

<p><span class="index" id="idxref:67"></span> <span class="index" id="idxref:68"></span> As with almost everything in
Go, functions are also <em>just</em> values. They can be assigned to variables as
follows:</p>

<pre><code class="language-go">import &quot;fmt&quot;

func main() {
	a := func() { <span class="callout">1</span>
		fmt.Println(&quot;Hello&quot;)
	} <span class="callout">2</span>
	a() <span class="callout">3</span>
}
</code></pre>

<p><code>a</code> is defined as an anonymous (nameless) function <span class="callout">1</span>.
Note the lack of parentheses <code>()</code> after <code>a</code>. If there were, that would be to <em>call</em>
some function with the name <code>a</code> before we have defined what <code>a</code> is. Once <code>a</code> is
defined, then we can <em>call</em> it, <span class="callout">3</span>.</p>

<p>Functions&ndash;as&ndash;values may be used in other places, for example maps. Here we
convert from integers to functions:</p>

<pre><code class="language-go">var xs = map[int]func() int{
    1: func() int { return 10 },
    2: func() int { return 20 },
    3: func() int { return 30 },
}
</code></pre>

<p>Note that the final comma on second to last line is <em>mandatory</em>.</p>

<p>Or you can write a function that takes a function as its parameter, for example
a <code>Map</code> function that works on <code>int</code> slices. This is left as an exercise for the
reader; see the exercise <a href="#map-function"></a>.</p>

<h2 id="callbacks">Callbacks</h2>

<p>Because functions are values they are easy to pass to functions, from where they
can be used as callbacks. First define a function that does &ldquo;something&rdquo; with an
integer value:</p>

<pre><code class="language-go">func printit(x int) {
    fmt.Printf(&quot;%v\n&quot;, x)
}
</code></pre>

<p>This function does not return a value and just prints its argument. The
<em>signature</em> <span class="index" id="idxref:69"></span> of this function is: <code>func printit(int)</code>,
or without the function name: <code>func(int)</code>. To create a new function that uses
this one as a callback we need to use this signature:</p>

<pre><code class="language-go">func callback(y int, f func(int)) {
    f(y)
}
</code></pre>

<p>Here we create a new function that takes two parameters: <code>y int</code>, i.e. just an
<code>int</code> and <code>f func(int)</code>, i.e. a function that takes an int and returns nothing.
The parameter <code>f</code> is the variable holding that function. It can be used as any
other function, and we execute the function on line 2 with the parameter <code>y</code>:
<code>f(y)</code></p>

<h2 id="deferred-code">Deferred Code</h2>

<p>Suppose you have a function in which you open a file and perform various writes
and reads on it. In such a function there are often spots where you want to
return early. If you do that, you will need to close the file descriptor you are
working on. This often leads to the following code:</p>

<pre><code class="language-go">func ReadWrite() bool {
    file.Open(&quot;file&quot;)
    // Do your thing
    if failureX {
        file.Close() <span class="callout">1</span>
        return false
    }

    if failureY {
        file.Close() <span class="callout">1</span>
        return false
    }
    file.Close() <span class="callout">1</span>
    return true  <span class="callout">2</span>
}
</code></pre>

<p>Note that we repeat a lot of code here; you can see the that <code>file.Close()</code> is
called at <span class="callout">1</span>. To overcome this, Go has the <code>defer</code> <span class="index" id="idxref:70"></span>
keyword. After <code>defer</code> you specify a function which is called just <em>before</em> <span class="callout">2</span>
the current function exits.</p>

<p>With <code>defer</code> we can rewrite the above code as follows. It makes the function
more readable and it puts the <code>Close</code> <em>right next</em> to the <code>Open</code>.</p>

<pre><code class="language-go">func ReadWrite() bool {
    file.Open(&quot;filename&quot;)
    defer file.Close() <span class="callout">1</span>
    // Do your thing
    if failureX {
        return false <span class="callout">2</span>
    }
    if failureY {
        return false <span class="callout">2</span>
    }
    return true <span class="callout">2</span>
}
</code></pre>

<p>At <span class="callout">1</span> <code>file.Close()</code> is added to the defer list. <span class="index" id="idxref:71"></span>
<code>Close</code> is now done automatically at <span class="callout">2</span>. This makes the function shorter and
more readable. It puts the <code>Close</code> right next to the <code>Open</code>.</p>

<p>You can put multiple functions on the &ldquo;defer list&rdquo;, like this example from</p>

<pre><code class="language-go">for i := 0; i &lt; 5; i++ {
    defer fmt.Printf(&quot;%d &quot;, i)
}
</code></pre>

<p>Deferred functions are executed in LIFO order, so the above code prints: <code>4
3 2 1 0</code>.</p>

<p>With <code>defer</code> you can even change return values, provided that you are using
named result parameters and a function literal <span class="index" id="idxref:72"></span><sup class="footnote-ref" id="fnref:A-function-liter"><a href="#fn:A-function-liter">9</a></sup>, i.e:</p>

<pre><code class="language-go">defer func() {/* ... */}()
</code></pre>

<p>Here we use a function without a name and specify the body of the function
inline, basically we&rsquo;re creating a nameless function on the spot. The final
braces are needed because <code>defer</code> needs a function call, not a function value.
If our anonymous function would take an parameter it would be easier to see why
we need the braces:</p>

<pre><code class="language-go">defer func(x int) {/* ... */}(5)
</code></pre>

<p>In this (unnamed) function you can access any named return parameter:</p>

<pre><code class="language-go">func f() (ret int)
    defer func() { <span class="callout">1</span>
        ret++
    }()
    return 0
}
</code></pre>

<p>Here <span class="callout">1</span> we specify our function, the named return value <code>ret</code> is initialized
with zero. The nameless function in the defer increments the value of <code>ret</code>
with 1. The <code>return 0</code> on line
5 <em>will not be the returned value</em>, because of <code>defer</code>. The function <code>f</code> will
return 1!</p>

<h2 id="variadic-parameter">Variadic Parameter</h2>

<p>Functions that take a variable number of parameters are known as variadic
functions. <span class="index" id="idxref:73"></span> To declare a function as variadic, do
something like this:</p>

<pre><code class="language-go">func myfunc(arg ...int) {}
</code></pre>

<p>The <code>arg ...int</code> instructs Go to see this as a function that takes a variable
number of arguments. Note that these arguments all have to have the type <code>int</code>.
In the body of your function the variable <code>arg</code> is a slice of ints:</p>

<pre><code class="language-go">for _, n := range arg {
    fmt.Printf(&quot;And the number is: %d\n&quot;, n)
}
</code></pre>

<p>We range over the arguments on the first line. We are not interested in the
index as returned by <code>range</code>, hence the use of the underscore there. In the body
of the <code>range</code> we just print the parameters we were given.</p>

<p>If you don&rsquo;t specify the type of the variadic argument it defaults to the empty
interface <code>interface{}</code> (see Chapter <a href="#interfaces"></a>).</p>

<p>Suppose we have another variadic function called <code>myfunc2</code>, the following
example shows how to pass variadic arguments to it:</p>

<pre><code class="language-go">func myfunc(arg ...int) {
    myfunc2(arg...)
    myfunc2(arg[:2]...)
}
</code></pre>

<p>With <code>myfunc2(arg...)</code> we pass all the parameters to <code>myfunc2</code>, but because the
variadic parameters is just a slice, we can use some slice tricks as well.</p>

<h2 id="panic-and-recovering">Panic and recovering</h2>

<p>Go does not have an exception mechanism: you cannot throw exceptions. Instead it
uses a panic-and-recover mechanism. It is worth remembering that you should use
this as a last resort, your code will not look, or be, better if it is littered
with panics. It&rsquo;s a powerful tool: use it wisely. So, how do you use it? In the
words of the Go Authors <cite class="informative"><a href="#go_blog_panic"></a></cite>:</p>

<dl>
<dt>Panic</dt>
<dd>is a built-in function that stops the ordinary flow of control and begins
panicking. When the function <code>F</code> calls <code>panic</code>, execution of <code>F</code> stops, any
deferred functions in <code>F</code> are executed normally, and then <code>F</code> returns to its
caller. To the caller, <code>F</code> then behaves like a call to <code>panic</code>. The process
continues up the stack until all functions in the current goroutine have
returned, at which point the program crashes. Panics can be initiated by
invoking <code>panic</code> directly. They can also be caused by <em>runtime errors</em>, such as
out-of-bounds array accesses.</dd>
<dt>Recover</dt>
<dd>is a built-in function that regains control of a panicking goroutine.
Recover is <em>only</em> useful inside <em>deferred</em> functions. During normal execution,
a call to <code>recover</code> will return <code>nil</code> and have no other effect. If the current
goroutine is panicking, a call to <code>recover</code> will capture the value given to
<code>panic</code> and resume normal execution.</dd>
</dl>

<p>This function checks if the function it gets as argument will panic when it is
executed<sup class="footnote-ref" id="fnref:Modified-from-a"><a href="#fn:Modified-from-a">10</a></sup>:</p>

<pre><code class="language-go" callout="//">func Panic(f func()) (b bool) { <span class="callout">1</span>
    defer func() { <span class="callout">2</span>
        if x := recover(); x != nil {
            b = true
        }
    }()
    f() <span class="callout">3</span>
    return <span class="callout">4</span>
}
</code></pre>

<p>We define a new function <code>Panic</code> <span class="callout">1</span> that takes a function as an argument (see
<a href="#functions-as-values"></a>). It returns true if <code>f</code> panics when run, else false. We
then <span class="callout">2</span> define a <code>defer</code> function that utilizes <code>recover</code>. If the current
goroutine panics, this defer function will notice that. If <code>recover()</code> returns
non-<code>nil</code> we set <code>b</code> to true. At <span class="callout">3</span> Execute the function we received as the
argument. And finally <span class="callout">4</span> we return the value of <code>b</code>. Because <code>b</code> is a named
return parameter.</p>

<p>The following code fragment, shows how we can use this function:</p>

<pre><code class="language-go">func panicy() {
    var a []int
    a[3] = 5
}

func main() {
    fmt.Println(Panic(panicy))
}
</code></pre>

<p>On line 3 the <code>a[3] = 5</code> triggers a <em>runtime</em> out of bounds error which results
in a panic. Thus this program will print <code>true</code>. If we change line 2: <code>var
a []int</code> to <code>var a [4]int</code> the function <code>panicy</code> does not panic anymore. Why?</p>

<h2 id="exercises-1">Exercises</h2>

<h3 id="average-1" class="exercise" data-difficulty="0">Average</h3>

<ol>
<li>Write a function that calculates the average of a <code>float64</code> slice.</li>
</ol>

<h3 id="answer-3" class="answer">Answer</h3>

<ol>
<li>The following function calculates the average:</li>
</ol>

<pre><code class="language-go">package main

func average(xs []float64) (avg float64) { //&lt;1&gt;
	sum := 0.0
	switch len(xs) {
	case 0:                 //&lt;2&gt;
		avg = 0
	default:                //&lt;3&gt;
		for _, v := range xs {
			sum += v
		}
		avg = sum / float64(len(xs)) //&lt;4&gt;
	}
	return  //&lt;5&gt;
}
</code></pre>

<p>At <span class="callout">1</span> we use a named return parameter.  If the length of <code>xs</code> is zero <span class="callout">2</span>, we
 return 0.  Otherwise <span class="callout">3</span>, we calculate the average.  At <span class="callout">4</span>  we convert the
 value to a <code>float64</code> to make the division work as <code>len</code> returns an <code>int</code>.
 Finally, at <span class="callout">5</span> we reutrn our avarage.</p>

<h3 id="bubble-sort" class="exercise" data-difficulty="1">Bubble sort</h3>

<ol>
<li>Write a function that performs a bubble sort on a slice of ints. From <cite class="informative"><a href="#bubblesort"></a></cite>:</li>
</ol>

<blockquote>
<p>It works by repeatedly stepping through the list to be sorted, comparing each
pair of adjacent items and swapping them if they are in the wrong order. The
pass through the list is repeated until no swaps are needed, which indicates
that the list is sorted. The algorithm gets its name from the way smaller
elements &ldquo;bubble&rdquo; to the top of the list.</p>
</blockquote>

<p>It also gives an example in pseudo code:</p>

<pre><code>procedure bubbleSort( A : list of sortable items )
  do
    swapped = false
    for each i in 1 to length(A) - 1 inclusive do:
      if A[i-1] &gt; A[i] then
        swap( A[i-1], A[i] )
        swapped = true
      end if
    end for
  while swapped
end procedure
</code></pre>

<h3 id="answer-4">Answer</h3>

<ol>
<li><p>Bubble sort isn&rsquo;t terribly efficient. For $<span class="math inline">\(n\)</span><span class="math inline">\( elements it scales \)</span><span class="math inline">\(O(n^2)\)</span>$.
But bubble sort is easy to implement:</p>

<pre><code class="language-go">
func main() {
	n := []int{5, -1, 0, 12, 3, 5}
	fmt.Printf(&quot;unsorted %v\n&quot;, n)
	bubblesort(n)
	fmt.Printf(&quot;sorted %v\n&quot;, n)
}

func bubblesort(n []int) {
	for i := 0; i &lt; len(n)-1; i++ {
		for j := i + 1; j &lt; len(n); j++ {
			if n[j] &lt; n[i] {
				n[i], n[j] = n[j], n[i]
			}
</code></pre>
<p>Because a slice is a reference type, the <code>bubblesort</code> function works and
does not need to return a sorted slice.</p></li>
</ol>

<h3 id="for-loop-ii" class="exercise" data-difficulty="0">For-loop II</h3>

<ol>
<li>Take what you did in exercise to write the for loop and extend it a bit.
Put the body of the for loop - the <code>fmt.Printf</code> - in a separate function.</li>
</ol>

<h3 id="answer-5" class="answer">Answer</h3>

<p>1.
 &lt;{{src/for-func.go}}</p>

<h3 id="fibonacci" class="exercise" data-difficulty="1">Fibonacci</h3>

<ol>
<li><p>The Fibonacci sequence starts as follows: $<span class="math inline">\(1, 1, 2, 3, 5, 8, 13, \ldots\)</span><span class="math inline">\(
Or in mathematical terms: \)</span><span class="math inline">\( x_1 = 1; x_2 = 1; x_n = x_{n-1} + x_{n-2}\quad\forall n &gt; 2 \)</span>$.</p>

<p>Write a function that takes an <code>int</code> value and gives
that many terms of the Fibonacci sequence.</p></li>
</ol>

<h3 id="answer-6" class="answer">Answer</h3>

<ol>
<li>The following program calculates Fibonacci numbers:</li>
</ol>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func fibonacci(value int) []int {
	x := make([]int, value) <span class="callout">1</span>
	x[0], x[1] = 1, 1       <span class="callout">2</span>
	for n := 2; n &lt; value; n++ {
		x[n] = x[n-1] + x[n-2] <span class="callout">3</span>
	}
	return x <span class="callout">4</span>
}

func main() {
	for _, term := range fibonacci(10) { <span class="callout">5</span>
		fmt.Printf(&quot;%v &quot;, term)
	}
}
</code></pre>

<p>At <span class="callout">1</span> we create an array to hold the integers up to the value given in
the function call.  At <span class="callout">2</span> we start the Fibonacci calculation. Then <span class="callout">3</span>:
$<span class="math inline">\(x_n = x_{n-1} + x_{n-2}\)</span>$.  At <span class="callout">4</span> we return the <em>entire</em> array.
And at <span class="callout">5</span> we use the <code>range</code> keyword to  &ldquo;walk&rdquo; the numbers returned by the
Fibonacci function. Here up to 10. Finally, we print the numbers.</p>

<h3 id="var-args" class="exercise" data-difficulty="1">Var args</h3>

<ol>
<li>Write a function that takes a variable number of ints and print each integer on a separate line.</li>
</ol>

<h3 id="answer-7">Answer</h3>

<ol>
<li><p>For this we need the <code>{...}</code>-syntax to signal we define a
function that takes an arbitrary number of arguments.</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	printthem(1, 4, 5, 7, 4)
	printthem(1, 2, 4)
}

func printthem(numbers ...int) {
	for _, d := range numbers {
		fmt.Printf(&quot;%d\n&quot;, d)
	}
}
</code></pre></li>
</ol>

<h3 id="functions-that-return-functions" class="exercise" data-difficulty="1">Functions that return functions</h3>

<ol>
<li><p>Write a function that returns a function that performs a $<span class="math inline">\(+2\)</span>$ on integers. Name the function <code>plusTwo</code>.
You should then be able do the following:</p>

<pre><code class="language-go">p := plusTwo()
fmt.Printf(&quot;%v\n&quot;, p(2))
</code></pre>
<p>Which should print 4. See <a href="#callbacks"></a>.</p></li>

<li><p>Generalize the function from above and create a <code>plusX(x)</code> which returns functions that add <code>x</code> to an integer.</p></li>
</ol>

<h3 id="answer-8" class="answer">Answer</h3>

<ol>
<li><p>Define a new function that returns a function: <code>return func(x int) int { return x + 2 }</code>
Function literals at work, we define the +2&ndash;function right there in the return statement.</p>

<pre><code class="language-go" callout="//">func main() {
   p2 := plusTwo()
   fmt.Printf(&quot;%v\n&quot;,p2(2))
}


func plusTwo() func(int) int { <span class="callout">1</span>
    return func(x int) int { return x + 2 } <span class="callout">2</span>
}
</code></pre></li>

<li><p>Here we use a closure:</p>

<pre><code class="language-go">func plusX(x int) func(int) int { <span class="callout">1</span>
   return func(y int) int { return x + y } <span class="callout">2</span>
}
</code></pre>
<p>Here <span class="callout">1</span>, we again define a function that returns a function.
We use the <em>local</em> variable <code>x</code> in the function literal at <span class="callout">2</span>.</p></li>
</ol>

<h3 id="maximum" class="exercise" data-difficulty="0">Maximum</h3>

<ol>
<li>Write a function that finds the
maximum value in an <code>int</code> slice (<code>[]int</code>).</li>
</ol>

<h3 id="answer-9" class="answer">Answer</h3>

<ol>
<li><p>This function returns the largest int in the slice \var{l}:</p>

<pre><code class="language-go">func max(l []int) (max int) {   <span class="callout">1</span>
    max = l[0]
    for _, v := range l {   <span class="callout">2</span>
        if v &gt; max {    <span class="callout">3</span>
            max = v
        }
    }
    return <span class="callout">4</span>
}
</code></pre>
<p>At <span class="callout">1</span> we use a named return parameter.
At <span class="callout">2</span> we loop over <code>l</code>. The index of the element is not important.
At <span class="callout">3</span>, if we find a new maximum, we remember it.
And at <span class="callout">4</span> we have a &ldquo;lone&rdquo; return; the current value of <code>max</code> is now returned.</p></li>
</ol>

<h3 id="map-function" class="exercise" data-difficulty="1">Map function</h3>

<p>A <code>map()</code>-function is a function that takes
a function and a list. The function is applied to
each member in the list and a new list containing
these calculated values is returned.
Thus:</p>
<p><span class="math display">\[ \mathrm{map}(f(), (a_1,a_2,\ldots,a_{n-1},a_n)) =  (f(a_1), f(a_2),\ldots,f(a_{n-1}), f(a_n)) \]</span></p>
<ol>
<li>Write a simple
<code>map()</code>-function in Go. It is sufficient for this function only to work for ints.</li>
</ol>

<h3 id="answer-10" class="answer">Answer</h3>

<ol>
<li><p>A possible answer:</p>

<pre><code class="language-go">func Map(f func(int) int, l []int) []int {
    j := make([]int, len(l))
    for k, v := range l {
        j[k] = f(v)
    }
    return j
}


func main() {
    m := []int{1, 3, 4}
    f := func(i int) int {
        return i * i
    }
    fmt.Printf(&quot;%v&quot;, (Map(f, m)))
}
</code></pre></li>
</ol>

<h3 id="stack" class="exercise" data-difficulty="1">Stack</h3>

<ol>
<li>Create a simple stack which can hold a
fixed number of ints. It does not have to grow beyond this limit.
Define <code>push</code> &ndash; put something on the stack &ndash; and <code>pop</code>
&ndash; retrieve something from the stack &ndash; functions. The stack should be
a LIFO (last in, first out) stack.</li>
</ol>

<p><img src="fig/stack.png" alt="A stack" title="A stack." /></p>

<ol start="2">
<li>Write a <code>String</code> method which
converts the stack to a string representation.
The stack in the figure could be represented as: <code>[0:m] [1:l] [2:k]</code> .</li>
</ol>

<h3 id="answer-11" class="answer">Answer</h3>

<ol>
<li><p>First we define a new type that represents a stack; we need an
array (to hold the keys) and an index, which points to the last element.
Our small stack can only hold 10 elements.</p>

<pre><code class="language-go">type stack struct {
    i    int
    data [10]int
}
</code></pre></li>
</ol>

<p>Next we need the <code>push</code> and <code>pop</code> functions to actually
use the thing. First we show the <em>wrong</em> solution!</p>

<p>In Go, data passed to functions is <em>passed-by-value</em> meaning a copy
is created and given to the function. The first stab for the function
<code>push</code> could be:</p>

<pre><code class="language-go">func (s stack) push(k int) {
    if s.i+1 &gt; 9 {
            return
    }
    s.data[s.i] = k
    s.i++
}
</code></pre>

<p>The function works on the <code>s</code> which is of the type <code>stack</code>. To
use this we just call <code>s.push(50)</code>, to push the integer 50 on
the stack. But the push function gets a copy of <code>s</code>, so it is
<em>not</em> working on the <em>real</em> thing. Nothing gets pushed to our
stack. For example the following code:</p>

<pre><code class="language-go">var s stack
s.push(25)
fmt.Printf(&quot;stack %v\n&quot;, s);
s.push(14)
fmt.Printf(&quot;stack %v\n&quot;, s);
</code></pre>

<p>prints:</p>

<pre><code>stack [0:0]
stack [0:0]
</code></pre>

<p>To solve this we need to give the function <code>push</code> a pointer
to the stack. This means we need to change <code>push</code> from</p>

<pre><code class="language-go">func (s stack) push(k int)
</code></pre>

<p>to</p>

<pre><code class="language-go">func (s *stack) push(k int).
</code></pre>

<p>We should now use <code>new()</code> (see <a href="#allocation-with-new"></a>).
in <a href="#beyond-the-basics"></a> to create a <em>pointer</em> to a newly
allocated <code>stack</code>, so line 1 from the example above needs to be
<code>s := new(stack)</code> .</p>

<p>And our two functions become:</p>

<pre><code class="language-go">func (s *stack) push(k int) {
    s.data[s.i] = k
    s.i++
}

func (s *stack) pop() int {
    s.i--
    ret := s.data[s.i]
    s.data[s.i] = 0
    return ret
}
</code></pre>

<p>Which we then use as follows:</p>

<pre><code class="language-go">func main() {
    var s stack
    s.push(25)
    s.push(14)
    fmt.Printf(&quot;stack %v\n&quot;, s)
}
</code></pre>

<ol start="2">
<li><p><code>fmt.Printf(&quot;%v&quot;)</code> can
print any value (<code>%v</code>) that satisfies the <code>Stringer</code> interface
(see <a href="#interfaces"></a>).
For this to work we only need to define a <code>String()</code> function for
our type:</p>

<pre><code class="language-go">func (s stack) String() string {
    var str string
    for i := 0; i &lt;= s.i; i++ {
        str = str + &quot;[&quot; +
            strconv.Itoa(i) + &quot;:&quot; + strconv.Itoa(s.data[i]) + &quot;]&quot;
    }
    return str
}
</code></pre></li>
</ol>

<h1 id="packages">Packages</h1>
<figure class="epigraph">
<blockquote>
<p>&rdquo;^&rdquo;</p>
</blockquote>
<figcaption>Answer to whether there is a bit wise negation operator &ndash; Ken Thompson
</figcaption>
</figure>

<p>A package is a collection of functions and data.</p>

<p>You declare a package with the <code>package</code><span class="index" id="idxref:74"></span> keyword. The
filename does not have to match the package name. The convention for package
names is to use lowercase characters. Go packages may consist of multiple files,
but they share the <code>package &lt;name&gt;</code> line. Let&rsquo;s define a package <code>even</code> in the
file <code>even.go</code>.</p>

<p><span class="index" id="idxref:75"></span>
<span class="index" id="idxref:76"></span>
<span class="index" id="idxref:77"></span></p>

<pre><code class="language-go">package even <span class="callout">1</span>

func Even(i int) bool { <span class="callout">2</span>
	return i%2 == 0
}

func odd(i int) bool { <span class="callout">3</span>
	return i%2 == 1
}
</code></pre>

<p>Here <span class="callout">1</span> we start a new namespace: &ldquo;even&rdquo;. The function <code>Even</code> <span class="callout">2</span> starts with
a capital letter. This means the function is <em>exported</em>, and may be used outside
our package (more on that later). The function <code>odd</code> <span class="callout">3</span> does not start with
a capital letter, so it is a <em>private</em> function.</p>

<p>Now we just need to build the package. We create a directory under <code>$GOPATH</code>,
and copy <code>even.go</code> there (see <a href="#compiling-and-running-code"></a> in <a href="#basics"></a>).</p>

<pre><code>% mkdir $GOPATH/src/even
% cp even.go $GOPATH/src/even
% go build
% go install
</code></pre>

<p>Now we can use the package in our own program <code>myeven.go</code>:</p>

<pre><code class="language-go">package main

import ( <span class="callout">1</span>
	&quot;even&quot; <span class="callout">2</span>
	&quot;fmt&quot;  <span class="callout">3</span>
)

func main() {
	i := 5
	fmt.Printf(&quot;Is %d even? %v\n&quot;, i, even.Even(i)) <span class="callout">4</span>
}
</code></pre>

<p>Import <span class="callout">1</span> the following packages. The <em>local</em> package <code>even</code> is imported here
<span class="callout">2</span>. This <span class="callout">3</span> imports the official <code>fmt</code> package. And now we use <span class="callout">4</span> the
function from the <code>even</code> package. The syntax for accessing a function from
a package is <code>&lt;package&gt;.FunctionName()</code>. And finally we can build our program.</p>

<pre><code>% go build myeven.go
% ./myeven
Is 5 even? false
</code></pre>

<p>If we change our <code>myeven.go</code> at <span class="callout">4</span> to use the unexported function <code>even.odd</code>:
<code>fmt.Printf(&quot;Is %d even? %v\n&quot;, i, even.odd(i))</code> We get an error when compiling,
because we are trying to use a
<em>private</em> function:</p>

<pre><code>myeven.go: cannot refer to unexported name even.odd
</code></pre>

<p>Note that the &ldquo;starts with capital $<span class="math inline">\(\rightarrow\)</span><span class="math inline">\( exported&quot;, &quot;starts with
lower\-case \)</span><span class="math inline">\(\rightarrow\)</span>$ private&rdquo; rule also extends to other names (new
types, global variables) defined in the package. Note that the term &ldquo;capital&rdquo; is
not limited to US-ASCII &ndash; it extends to all bicameral alphabets (Latin, Greek,
Cyrillic, Armenian and Coptic).</p>

<h2 id="identifiers">Identifiers</h2>

<p>The Go standard library names some function with the old (Unix) names while
others are in CamelCase. The convention is to leave well-known legacy
not-quite-words alone rather than try to figure out where the capital letters
go:  <code>Atoi</code>, <code>Getwd</code>, <code>Chmod</code>. CamelCasing works best when you have whole words
to work with: <code>ReadFile</code>, <code>NewWriter</code>, <code>MakeSlice</code>. The convention in Go is to
use CamelCase rather than underscores to write multi-word names.</p>

<p>As we did above in our <code>myeven</code> program, accessing content from an imported
(with <code>import</code> <span class="index" id="idxref:78"></span>) package is done with using the package&rsquo;s
name and then a dot.  After <span class="index" id="idxref:79"></span> <code>import &quot;bytes&quot;</code> the importing
program can talk about <code>bytes.Buffer</code>. A package name should be good, short,
concise and evocative. The convention in Go is that package names are lowercase,
single word names.</p>

<p>The package name used in the <code>import</code> statement is the default name used. But if
the need arises (two different packages with the same name for instance), you
can override this default: <code>import bar &quot;bytes&quot;</code> The function <code>Buffer</code> is now
accessed as <code>bar.Buffer</code>.</p>

<p>Another convention is that the package name is the base name of its source
directory; the package in <code>src/compress/gzip</code> is imported as <code>compress/gzip</code> but
has name <code>gzip</code>, not <code>compress/gzip</code>.</p>

<p>It is important to avoid stuttering when naming things. For instance, the
buffered reader type in the <code>bufio</code> <span class="index" id="idxref:80"></span> package is called
<code>Reader</code>, not <code>BufReader</code>, because users see it as <code>bufio.Reader</code>, which is
a clear, concise name.</p>

<p>Similarly, the function to make new instances of <code>ring.Ring</code> (package
<code>container/ring</code>), would normally be called <code>NewRing</code>, but since <code>Ring</code> is the
only type exported by the package, and since the package is called
<code>ring</code><span class="index" id="idxref:81"></span>, it&rsquo;s called just <code>New</code>. Clients of the package see
that as <code>ring.New</code>. Use the package structure to help you choose good names.</p>

<p>Another short example is <code>once.Do</code> (see package <code>sync</code>); <code>once.Do(setup)</code> reads
well and would not be improved by writing <code>once.DoOrWaitUntilDone(setup)</code>. Long
names don&rsquo;t automatically make things more readable.</p>

<h2 id="documenting-packages">Documenting packages</h2>

<p>When we created our <code>even</code> package, we skipped over an important item:
documentation. Each package should have a <em>package comment</em>, a block comment
preceding the <code>package</code> clause. In our case we should extend the beginning of
the package, with:</p>

<pre><code class="language-go">// The even package implements a fast function for detecting if an integer
// is even or not.
package even
</code></pre>

<p>When running <code>go doc</code> this will show up at the top of the page. When a package
consists of multiple files the package comment should only appear in one
file. A common convention (in really big packages) is to have a separate
<code>doc.go</code> that only holds the package comment. Here is a snippet from the
official <code>regexp</code> package:</p>

<pre><code class="language-go">/*
    The regexp package implements a simple library for
    regular expressions.

    The syntax of the regular expressions accepted is:

    regexp:
        concatenation { '|' concatenation }
*/
package regexp
</code></pre>

<p>Each defined (and exported) function should have a small line of text
documenting the behavior of the function. Again to extend our <code>even</code> package:</p>

<pre><code class="language-go">// Even returns true of i is even. Otherwise false is returned.
func Even(i int) bool {
</code></pre>

<p>And even though <code>odd</code> is not exported, it&rsquo;s good form to document it as well.</p>

<pre><code class="language-go">// odd is the opposite of Even.
func odd(i int) bool {
</code></pre>

<h2 id="testing-packages">Testing packages</h2>

<p>In Go it is customary to write (unit) tests for your package. Writing tests
involves the <code>testing</code> package and the program <code>go test</code><span class="index" id="idxref:82"></span>.
Both have excellent documentation.</p>

<p>The <code>go test</code> program runs all the test functions. Without any defined tests for
our <code>even</code> package, <code>go test</code> yields:</p>

<pre><code>% go test
?       even    [no test files]
</code></pre>

<p>Let us fix this by defining a test in a test file. Test files reside in the
package directory and are named <code>*_test.go</code>. Those test files are just like
other Go programs, but <code>go test</code> will only execute the test functions. Each test
function has the same signature and its name should start with
<code>Test</code>: <code>func TestXxx(t *testing.T)</code> .</p>

<p>When writing test you will need to tell <code>go test</code> whether a test was
successful or not. A successful test function just returns. When
the test fails you can signal this with the following
functions. These are the most important ones (see <code>go doc testing</code> or <code>go help testfunc</code> for more):</p>

<ul>
<li><p><code>func (t *T) Fail()</code>, <code>Fail</code> marks the test function as having failed but
continues execution.</p></li>

<li><p><code>func (t *T) FailNow()</code>, <code>FailNow</code> marks the test function as having failed
and stops its execution. Any remaining tests in this file are skipped, and
execution continues with the next test.</p></li>

<li><p><code>func (t *T) Log(args ...interface{})</code>, <code>Log</code> formats its arguments using
default formatting, analogous to <code>Print()</code>, and records the text in the error
log.</p></li>

<li><p><code>func (t *T) Fatal(args ...interface{})</code>, <code>Fatal</code> is equivalent to <code>Log()</code>
followed by <code>FailNow()</code>.</p></li>
</ul>

<p>Putting all this together we can write our test. First we pick a name:
<code>even_test.go</code>. Then we add the following contents:</p>

<pre><code class="language-go">package even <span class="callout">1</span>

import &quot;testing&quot; <span class="callout">2</span>

func TestEven(t *testing.T) { <span class="callout">3</span>
	if !Even(2) {
		t.Log(&quot;2 should be even!&quot;)
		t.Fail()
	}
}
</code></pre>

<p>A test file belongs to the current <span class="callout">1</span> package. This is not only convenient, but
also allows tests of unexported functions and structures. We then <span class="callout">2</span> import the
<code>testing</code> package. And finally the test we want to execute. The code here <span class="callout">3</span>
should hold no surprises: we check if the <code>Even</code> function works OK. And now, the
moment we have been waiting form executing the test.</p>

<pre><code>% go test
ok      even    0.001s
</code></pre>

<p>Our test ran and reported <code>ok</code>. Success! If we redefine our test function, we
can see the result of a failed test:</p>

<pre><code class="language-go">// Entering the twilight zone
func TestEven(t *testing.T) {
    if Even(2) {
        t.Log(&quot;2 should be odd!&quot;)
        t.Fail()
    }
}
</code></pre>

<p>We now get:</p>

<pre><code>FAIL    even    0.004s
--- FAIL: TestEven (0.00 seconds)
    2 should be odd!
FAIL
</code></pre>

<p>And you can act accordingly (by fixing the test for instance).</p>

<p>Writing new packages should go hand in hand with writing (some)
documentation and test functions. It will make your code better and it
shows that you really put in the effort.</p>

<p>The Go test suite also allows you to incorporate example functions which serve
as documentation <em>and</em> as tests. These functions need to start with <code>Example</code>.</p>

<pre><code class="language-go">func ExampleEven() {
    if Even(2) {
        fmt.Printf(&quot;Is even\n&quot;)
    }
    // Output: <span class="callout">1</span>
    // Is even
}
</code></pre>

<p>Those last two comments lines <span class="callout">1</span> are part of the example, <code>go test</code> uses those
to check the <em>generated</em> output with the text in the comments. If there is
a mismatch the test fails.</p>

<h2 id="useful-packages">Useful packages</h2>

<p>The standard libary of Go includes a huge number of packages. It is very
enlightening to browse the <code>$GOROOT/src/pkg</code> directory and look at the
packages. We cannot comment on each package, but the following are worth
a mention: <sup class="footnote-ref" id="fnref:The-descriptions"><a href="#fn:The-descriptions">11</a></sup></p>

<dl>
<dt><code>fmt</code></dt>
<dd><p><span class="index" id="idxref:83"></span>
Package <code>fmt</code> implements formatted I/O with functions analogous
to C&rsquo;s <code>printf</code> and <code>scanf</code>. The format verbs are derived
from C&rsquo;s but are simpler. Some verbs (%-sequences) that can be used:</p>

<p>%v</p>

<dl>
<dd>The value in a default format. when printing structs, the plus flag (%+v) adds field names.</dd>
<dt>%#v</dt>
<dd>a Go-syntax representation of the value.</dd>
<dt>%T</dt>
<dd>a Go-syntax representation of the type of the value.</dd>
</dl></dd>
<dt><code>io</code></dt>
<dd><p><span class="index" id="idxref:84"></span>
This package provides basic interfaces to I/O primitives.
Its primary job is to wrap existing implementations of such primitives,
such as those in package os, into shared public interfaces that
abstract the functionality, plus some other related primitives.</p></dd>
<dt><code>bufio</code></dt>
<dd><p><span class="index" id="idxref:85"></span>
This package implements buffered I/O.  It wraps an
<code>io.Reader</code>
or
<code>io.Writer</code>
object, creating another object (Reader or Writer) that also implements
the interface but provides buffering and some help for textual I/O.</p></dd>
<dt><code>sort</code></dt>
<dd><p><span class="index" id="idxref:86"></span>
The <code>sort</code> package provides primitives for sorting arrays
and user-defined collections.</p></dd>
<dt><code>strconv</code></dt>
<dd><p><span class="index" id="idxref:87"></span>
The <code>strconv</code> package implements conversions to and from
string representations of basic data types.</p></dd>
<dt><code>os</code></dt>
<dd><p><span class="index" id="idxref:88"></span>
The <code>os</code> package provides a platform-independent interface to operating
system functionality.  The design is Unix-like.</p></dd>
<dt><code>sync</code></dt>
<dd><p><span class="index" id="idxref:89"></span>
The package <code>sync</code> provides basic synchronization primitives such as mutual
exclusion locks.</p></dd>
<dt><code>flag</code></dt>
<dd><p><span class="index" id="idxref:90"></span>
The <code>flag</code> package implements command-line flag parsing.</p></dd>
<dt><code>encoding/json</code></dt>
<dd><p><span class="index" id="idxref:91"></span>
The <code>encoding/json</code> package implements encoding and decoding of JSON objects as
defined in RFC 4627 <cite class="informative"><a href="#RFC4627"></a></cite>.</p></dd>
<dt><code>html/template</code></dt>
<dd><p><span class="index" id="idxref:92"></span>
Data-driven templates for generating textual output such as HTML.</p>

<p>Templates are executed by applying them to a data structure.  Annotations in
the template refer to elements of the data structure (typically a field of
a struct or a key in a map) to control execution and derive values to be
displayed.  The template walks the structure as it executes and the &ldquo;cursor&rdquo;
@ represents the value at the current location in the structure.</p></dd>
<dt><code>net/http</code></dt>
<dd><p><span class="index" id="idxref:93"></span>
The <code>net/http</code> package implements parsing of HTTP requests, replies,
and URLs and provides an extensible HTTP server and a basic
HTTP client.</p></dd>
<dt><code>unsafe</code></dt>
<dd><p><span class="index" id="idxref:94"></span>
The <code>unsafe</code> package contains operations that step around the type safety of Go programs.
Normally you don&rsquo;t need this package, but it is worth mentioning that <em>unsafe</em> Go programs
are possible.</p></dd>
<dt><code>reflect</code></dt>
<dd><p><span class="index" id="idxref:95"></span>
The <code>reflect</code> package implements run-time reflection, allowing a program to
manipulate objects with arbitrary types.  The typical use is to take a
value with static type <code>interface{}</code> and extract its dynamic type
information by calling <code>TypeOf</code>, which returns an object with interface
type <code>Type</code>. See <a href="#interfaces"></a>, Section <a href="#introspection-and-reflection"></a>.</p></dd>
<dt><code>os/exec</code></dt>
<dd><p><span class="index" id="idxref:96"></span> The <code>os/exec</code> package runs external commands.</p></dd>
</dl>

<h2 id="exercises-2">Exercises</h2>

<h3 id="stack-as-package" class="exercise" data-difficulty="0">Stack as package</h3>

<ol>
<li><p>See the Stack exercise. In this exercise we want to create a separate package
for that code. Create a proper package for your stack implementation, <code>Push</code>,
<code>Pop</code> and the <code>Stack</code> type need to be exported.</p></li>

<li><p>Write a simple unit test for this package.
You should at least test that a <code>Pop</code> works after a <code>Push</code>.</p></li>
</ol>

<h3 id="answer-12" class="answer">Answer</h3>

<ol>
<li><p>There are a few details that should be changed to make a proper package
for our stack. First, the exported functions should begin with a capital
letter and so should <code>Stack</code>. The package file is named <code>stack-as-package.go</code>
and contains:</p>

<pre><code class="language-go">package stack

// Stack holds the items.
type Stack struct {
	i    int
	data [10]int
}

// Push pushes an item on the stack.
func (s *Stack) Push(k int) {
	s.data[s.i] = k
	s.i++
}

// Pop pops an item from the stack.
func (s *Stack) Pop() (ret int) {
	s.i--
	ret = s.data[s.i]
	return
}
</code></pre></li>

<li><p>To make the unit testing work properly you need to do some
preparations. We&rsquo;ll come to those in a minute. First the actual unit test.
Create a file with the name <code>pushpop_test.go</code>, with the following contents:</p></li>
</ol>

<pre><code class="language-go">package stack

import &quot;testing&quot;

func TestPushPop(t *testing.T) {
	c := new(Stack)
	c.Push(5)
	if c.Pop() != 5 {
		t.Log(&quot;Pop doesn't give 5&quot;)
		t.Fail()
	}
}
</code></pre>

<p>For <code>go test</code> to work we need to put our package files in a directory
under <code>$GOPATH/src</code>:</p>

<pre><code>% mkdir $GOPATH/src/stack
% cp pushpop_test.go $GOPATH/src/stack
% cp stack-as-package.go $GOPATH/src/stack
</code></pre>

<p>Yields:</p>

<pre><code>% go test stack
ok stack 0.001s
</code></pre>

<h3 id="calculator" class="exercise" data-difficulty="2">Calculator</h3>

<ol>
<li>Create a reverse polish calculator. Use your stack package.</li>
</ol>

<h3 id="answer-13" class="answer">Answer</h3>

<ol>
<li>This is one answer:</li>
</ol>

<pre><code class="language-go">package main

import (
	&quot;bufio&quot;
	&quot;fmt&quot;
	&quot;os&quot;
	&quot;strconv&quot;
)

var reader *bufio.Reader = bufio.NewReader(os.Stdin)
var st = new(Stack)

type Stack struct {
	i    int
	data [10]int
}

func (s *Stack) push(k int) {
	if s.i+1 &gt; 9 {
		return
	}
	s.data[s.i] = k
	s.i++
}

func (s *Stack) pop() (ret int) {
	s.i--
	if s.i &lt; 0 {
		s.i = 0
		return
	}
	ret = s.data[s.i]
	return
}

func main() {
	for {
		s, err := reader.ReadString('\n')
		var token string
		if err != nil {
			return
		}
		for _, c := range s {
			switch {
			case c &gt;= '0' &amp;&amp; c &lt;= '9':
				token = token + string(c)
			case c == ' ':
				r, _ := strconv.Atoi(token)
				st.push(r)
				token = &quot;&quot;
			case c == '+':
				fmt.Printf(&quot;%d\n&quot;, st.pop()+st.pop())
			case c == '*':
				fmt.Printf(&quot;%d\n&quot;, st.pop()*st.pop())
			case c == '-':
				p := st.pop()
				q := st.pop()
				fmt.Printf(&quot;%d\n&quot;, q-p)
			case c == 'q':
				return
			default:
				//error
			}
		}
	}
}
</code></pre>

<h1 id="beyond-the-basics">Beyond the basics</h1>
<figure class="epigraph">
<blockquote>
<p>Go has pointers but not pointer arithmetic. You cannot use a pointer
variable to walk through the bytes of a string.</p>
</blockquote>
<figcaption>Go For C++ Programmers &ndash; Go Authors
</figcaption>
</figure>

<p>In this chapter we delve deeper in to the language.</p>

<p>Go has pointers. There is however no pointer arithmetic, so they act more like
references than pointers that you may know from C. Pointers are useful. Remember
that when you call a function in Go, the variables are
<em>pass-by-value</em>. So, for efficiency and the possibility to modify a passed value
 <em>in</em> functions we have pointers.</p>

<p>You declare a pointer by prefixing the type with an &lsquo;<code>*</code>&rsquo;: <code>var p *int</code>. Now <code>p</code>
is a pointer to an integer value. All newly declared variables are assigned
their zero value and pointers are no different. A newly declared pointer, or
just a pointer that points to nothing, has a nil-value <span class="index" id="idxref:97"></span>. In other
languages this is often called a NULL pointer in Go it is just <code>nil</code>. To make
a pointer point to something you can use the address-of operator
<span class="index" id="idxref:98"></span> (<code>&amp;</code>), which we demonstrate here:</p>

<pre><code class="language-go">var p *int
fmt.Printf(&quot;%v&quot;, p) <span class="callout">1</span>

var i int	    <span class="callout">2</span>
p = &amp;i		    <span class="callout">3</span>

fmt.Printf(&quot;%v&quot;, p) <span class="callout">4</span>
</code></pre>

<p>This <span class="callout">1</span> Prints <code>nil</code>. Declare <span class="callout">2</span> an integer variable <code>i</code>. Make <code>p</code> point <span class="callout">3</span>
to <code>i</code>, i.e. take the address of <code>i</code>. And this <span class="callout">4</span> will print something like
<code>0x7ff96b81c000a</code>. De-referencing a pointer is done by prefixing the pointer
variable with <code>*</code>.</p>

<p>As said, there is no pointer arithmetic, so if you write: <code>*p++</code>, it is
interpreted as <code>(*p)++</code>: first reference and then increment the
value.<span class="index" id="idxref:99"></span></p>

<h2 id="allocation">Allocation</h2>

<p>Go also has garbage collection, meaning that you don&rsquo;t have to worry about
memory deallocation.<sup class="footnote-ref" id="fnref:The-downside-is"><a href="#fn:The-downside-is">12</a></sup></p>

<p>To allocate memory Go has two primitives, <code>new</code> and <code>make</code>. They do different
things and apply to different types, which can be confusing, but the rules are
simple. The following sections show how to handle allocation in Go and hopefully
clarifies the somewhat artificial distinction between <code>new</code> <span class="index" id="idxref:100"></span>
and <code>make</code> <span class="index" id="idxref:101"></span>.</p>

<h3 id="allocation-with-new">Allocation with new</h3>

<p>The built-in function <code>new</code> is essentially the same as its namesakes in other
languages: <code>new(T)</code> allocates zeroed storage for a new item of type <code>T</code> and
returns its address, a value of type <code>*T</code>. Or in other words, it returns
a pointer to a newly allocated zero value of type <code>T</code>. This is important to
remember.</p>

<p>The documentation for <code>bytes.Buffer</code> states that &ldquo;the zero value for Buffer is
an empty buffer ready to use.&rdquo;. Similarly, <code>sync.Mutex</code> does not have an
explicit constructor or Init method. Instead, the zero value for a <code>sync.Mutex</code>
is defined to be an unlocked mutex.</p>

<h3 id="allocation-with-make">Allocation with make</h3>

<p>The built-in function <code>make(T, args)</code> serves a purpose different from <code>new(T)</code>.
It creates slices, maps, and channels <em>only</em>, and it returns an initialized (not
zero!) value of type <code>T</code>, and not a pointer: <code>*T</code>. The reason for the
distinction is that these three types are, under the covers, references to data
structures that must be initialized before use. A slice, for example, is
a three-item descriptor containing a pointer to the data (inside an array), the
length, and the capacity; until those items are initialized, the slice is <code>nil</code>.
For slices, maps, and channels, <code>make</code> initializes the internal data structure
and prepares the value for use.</p>

<p>For instance, <code>make([]int, 10, 100)</code> allocates an array of 100 ints and then
creates a slice structure with length 10 and a capacity of 100 pointing at the
first 10 elements of the array. In contrast, <code>new([]int)</code> returns a pointer to
a newly allocated, zeroed slice structure, that is, a pointer to a <code>nil</code> slice
value. These examples illustrate the difference between <code>new</code> and <code>make</code>.</p>

<pre><code class="language-go">var p *[]int = new([]int)       <span class="callout">1</span>
var v  []int = make([]int, 100) <span class="callout">2</span>

var p *[]int = new([]int)       <span class="callout">3</span>
*p = make([]int, 100, 100)

v := make([]int, 100)           <span class="callout">4</span>
</code></pre>

<p>Allocates <span class="callout">1</span> slice structure; rarely useful. <code>v</code> <span class="callout">2</span> refers to a new array of
100 ints. At <span class="callout">3</span> we make it unnecessarily complex, <span class="callout">4</span> is more idiomatic.</p>

<p>Remember that <code>make</code> applies only to maps, slices and channels and does not
return a pointer. To obtain an explicit pointer allocate with <code>new</code>.</p>

<aside>
<p><strong>new</strong> allocates; <strong>make</strong> initializes.</p>

<p>The above two paragraphs can be summarized as:</p>

<ul>
<li><code>new(T)</code> returns <code>*T</code> pointing to a zeroed <code>T</code></li>
<li><code>make(T)</code> returns an initialized <code>T</code></li>
</ul>

<p>And of course <code>make</code> is only used for slices, maps and channels.</p>
</aside>

<h3 id="constructors-and-composite-literals">Constructors and composite literals</h3>

<p>Sometimes the zero value isn&rsquo;t good enough and an initializing constructor is
necessary, as in this example taken from the package <code>os</code>.</p>

<pre><code class="language-go">func NewFile(fd int, name string) *File {
    if fd &lt; 0 {
        return nil
    }
    f := new(File)
    f.fd = fd
    f.name = name
    f.dirinfo = nil
    f.nepipe = 0
    return f
}
</code></pre>

<p>There&rsquo;s a lot of boiler plate in there. We can simplify it using a
<em>composite literal</em> <span class="index" id="idxref:102"></span>, which is an expression that
 creates a new instance each time it is evaluated.</p>

<pre><code class="language-go">func NewFile(fd int, name string) *File {
    if fd &lt; 0 {
        return nil
    }
    f := File{fd, name, nil, 0}
    return &amp;f	<span class="callout">1</span>
}
</code></pre>

<p>It is OK to return the address of a local variable <span class="callout">1</span> the storage associated
with the variable survives after the function returns.</p>

<p>In fact, taking the address of a composite literal allocates a fresh instance
each time it is evaluated, so we can combine these last two lines.<sup class="footnote-ref" id="fnref:Taking-the-addre"><a href="#fn:Taking-the-addre">13</a></sup></p>

<pre><code class="language-go">return &amp;File{fd, name, nil, 0}
</code></pre>

<p>The items (called fields) of a composite literal are laid out in order and must
all be present. However, by labeling the elements explicitly as field:value
pairs, the initializers can appear in any order, with the missing ones left as
their respective zero values. Thus we could say</p>

<pre><code class="language-go">return &amp;File{fd: fd, name: name}
</code></pre>

<p>As a limiting case, if a composite literal contains no fields at all, it creates
a zero value for the type. The expressions <code>new(File)</code> and <code>&amp;File{}</code> are
equivalent. In fact the use of <code>new</code> is discouraged.</p>

<p>Composite literals can also be created for arrays, slices, and maps, with the
field labels being indices or map keys as appropriate. In these examples, the
initializations work regardless of the values of <code>Enone</code>, and <code>Einval</code>, as long
as they are distinct:</p>

<pre><code class="language-go">ar := [...]string{Enone: &quot;no error&quot;, Einval: &quot;invalid argument&quot;}
sl := []string{Enone: &quot;no error&quot;, Einval: &quot;invalid argument&quot;}
ma := map[int]string {Enone: &quot;no error&quot;, Einval: &quot;invalid argument&quot;}
</code></pre>

<h2 id="defining-your-own-types">Defining your own types</h2>

<p>Of course Go allows you to define new types, it does this with the
<code>type</code><span class="index" id="idxref:103"></span> keyword: <code>type foo int</code></p>

<p>This creates a new type <code>foo</code> which acts like an <code>int</code>. Creating more sophisticated
types is done with the <code>struct</code> <span class="index" id="idxref:104"></span> keyword. An example would
be when we want record somebody&rsquo;s name (<code>string</code>) and age (<code>int</code>) in a single
structure and make it a new type:</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

type NameAge struct {
	name string // Both non exported fields.
	age  int
}

func main() {
	a := new(NameAge)
	a.name = &quot;Pete&quot;
	a.age = 42
	fmt.Printf(&quot;%v\n&quot;, a)
}
</code></pre>

<p>Apropos, the output of <code>fmt.Printf(&quot;%v\n&quot;, a)</code> is <code>&amp;{Pete 42}</code></p>

<p>That is nice! Go knows how to print your structure. If you only want to print
one, or a few, fields of the structure you&rsquo;ll need to use <code>.&lt;field name&gt;</code>. For
example to only print the name:</p>

<pre><code class="language-go">fmt.Printf(&quot;%s&quot;, a.name)
</code></pre>

<h3 id="more-on-structure-fields">More on structure fields</h3>

<p>As said each item in a structure is called a field<span class="index" id="idxref:105"></span>. A struct with no
fields: <code>struct {}</code>. Or one with four fields:</p>

<pre><code class="language-go">struct {
    x, y int
    A *[]int
    F func()
}
</code></pre>

<p>If you omit the name for a field, you create an anonymous field (((field,
anonymous))), for instance:</p>

<pre><code class="language-go">struct {
    T1        // Field name is T1.
    *T2       // Field name is T2.
    P.T3      // Field name is T3.
    x, y int  // Field names are x and y.
}
</code></pre>

<p>Note that field names that start with a capital letter are exported, i.e. can be
set or read from other packages. Field names that start with a lowercase are
private to the current package. The same goes for functions defined in packages,
see <a href="#packages"></a> for the details.</p>

<h3 id="methods">Methods</h3>

<p>If you create functions that work on your newly defined type, you can take two
routes:</p>

<ol>
<li>Create a function that takes the type as an argument.</li>
</ol>

<pre><code class="language-go">func doSomething(n1 *NameAge, n2 int) { /* */ }
</code></pre>

<ol start="2">
<li>Create a function that works on the type (see <em>receiver</em> in <a href="#functions"></a>):</li>
</ol>

<pre><code class="language-go">func (n1 *NameAge) doSomething(n2 int) { /* */ }
</code></pre>

<p>This is a method call, which can be used as:</p>

<pre><code class="language-go">var n *NameAge
n.doSomething(2)
</code></pre>

<p>Whether to use a function or method is entirely up to the programmer, but if you
want to satisfy an interface (see the next chapter) you must use methods. If no
such requirement exists it is a matter of taste whether to use functions or
methods.</p>

<p>But keep the following in mind, this is quoted from <cite class="informative"><a href="#go_spec"></a></cite>:</p>

<blockquote>
<p>If <code>x</code> is
addressable and <code>&amp;x</code>&rsquo;s method set contains <code>m</code>,
<code>x.m()</code> is shorthand for <code>(&amp;x).m()</code>.</p>
</blockquote>

<p>In the above case this means that the following is <em>not</em> an error:</p>

<pre><code class="language-go">var n NameAge	    // Not a pointer
n.doSomething(2)
</code></pre>

<p>Here Go will search the method list for <code>n</code> of type <code>NameAge</code>, come up empty and
will then <em>also</em> search the method list for the type <code>*NameAge</code> and will
translate this call to <code>(&amp;n).doSomething(2)</code>.</p>

<p>There is a subtle but major difference between the following type declarations.
Also see the Section &ldquo;Type Declarations&rdquo; <cite class="informative"><a href="#go_spec"></a></cite>. Suppose we have:</p>

<pre><code class="language-go">// A Mutex is a data type with two methods, Lock and Unlock.
type Mutex struct         { /* Mutex fields */ }
func (m *Mutex) Lock()    { /* Lock impl. */ }
func (m *Mutex) Unlock()  { /* Unlock impl. */ }
</code></pre>

<p>We now create two types in two different manners:</p>

<ul>
<li><code>type NewMutex Mutex</code>.</li>
<li><code>type PrintableMutex struct{Mutex}</code>.</li>
</ul>

<p><code>NewMutex</code> is equal to <code>Mutex</code>, but it <em>does not</em> have <em>any</em> of the methods of
<code>Mutex</code>. In other words its method set is empty. But <code>PrintableMutex</code> <em>has</em>
<em>inherited</em> <span class="index" id="idxref:106"></span> the method set from <code>Mutex</code>. The Go term
 for this is <em>embedding</em> <span class="index" id="idxref:107"></span>. In the words of <cite class="informative"><a href="#go_spec"></a></cite>:</p>

<blockquote>
<p>The method set of <code>*PrintableMutex</code> contains the methods
<code>Lock</code> and <code>Unlock</code> bound to its anonymous field <code>Mutex</code>.</p>
</blockquote>

<h2 id="conversions">Conversions</h2>

<p>Sometimes you want to convert a type to another type. This is possible in Go,
but there are some rules. For starters, converting from one value to another is
done by operators (that look like functions: <code>byte()</code>) and not all conversions
are allowed.</p>
<figure>
<table>
<thead>
<tr>
<th>From</th>
<th><code>b []byte</code></th>
<th><code>i []int</code></th>
<th><code>r []rune</code></th>
<th><code>s string</code></th>
<th><code>f float32</code></th>
<th><code>i int</code></th>
</tr>
</thead>

<tbody>
<tr>
<td><strong>To</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td><code>[]byte</code></td>
<td>·</td>
<td></td>
<td></td>
<td><code>[]byte(s)</code></td>
<td></td>
<td></td>
</tr>

<tr>
<td><code>[]int</code></td>
<td></td>
<td>·</td>
<td></td>
<td><code>[]int(s)</code></td>
<td></td>
<td></td>
</tr>

<tr>
<td><code>[]rune</code></td>
<td></td>
<td></td>
<td></td>
<td><code>[]rune(s)</code></td>
<td></td>
<td></td>
</tr>

<tr>
<td><code>string</code></td>
<td><code>string(b)</code></td>
<td><code>string(i)</code></td>
<td><code>string(r)</code></td>
<td>·</td>
<td></td>
<td></td>
</tr>

<tr>
<td><code>float32</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>·</td>
<td><code>float32(i)</code></td>
</tr>

<tr>
<td><code>int</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><code>int(f)</code></td>
<td>·</td>
</tr>
</tbody>
</table>
<figcaption>Valid conversions, <code>float64</code> works the same as <code>float32</code>.</figcaption>
</figure>

<ul>
<li><p>From a <code>string</code> to a slice of bytes or runes.</p>

<pre><code class="language-go">mystring := &quot;hello this is string&quot;
byteslice := []byte(mystring)
</code></pre>
<p>Converts to a <code>byte</code> slice, each <code>byte</code> contains the integer value of the
corresponding byte in the string. Note that as strings in Go are encoded in
UTF-8 some characters in the string may end up in 1, 2, 3 or 4 bytes.</p>

<pre><code class="language-go">runeslice  := []rune(mystring)
</code></pre>
<p>Converts to an <code>rune</code> slice, each <code>rune</code> contains a Unicode code point.
Every character from the string corresponds to one rune.</p></li>

<li><p>From a slice of bytes or runes to a <code>string</code>.</p>

<pre><code class="language-go">b := []byte{'h','e','l','l','o'} // Composite literal.
s := string(b)
i := []rune{257,1024,65}
r := string(i)
</code></pre></li>
</ul>

<p>For numeric values the following conversions are defined:</p>

<ul>
<li>Convert to an integer with a specific (bit) length: <code>uint8(int)</code></li>
<li>From floating point to an integer value: <code>int(float32)</code>. This discards the
fraction part from the floating point value.</li>
<li>And the other way around: <code>float32(int)</code>.</li>
</ul>

<h3 id="user-defined-types-and-conversions">User defined types and conversions</h3>

<p>How can you convert between the types you have defined yourself? We create two
types here <code>Foo</code> and <code>Bar</code>, where <code>Bar</code> is an alias for <code>Foo</code>:</p>

<pre><code class="language-go">type foo struct { int }  // Anonymous struct field.
type bar foo             // bar is an alias for foo.
</code></pre>

<p>Then we:</p>

<pre><code class="language-go">var b bar = bar{1} // Declare `b` to be a `bar`.
var f foo = b	   // Assign `b` to `f`.
</code></pre>

<p>Which fails on the last line with:
<code>cannot use b (type bar) as type foo in assignment</code></p>

<p>This can be fixed with a conversion: <code>var f foo = foo(b)</code></p>

<p>Note that converting structures that are not identical in their fields is more
difficult. Also note that converting <code>b</code> to a plain <code>int</code> also fails; an integer
is not the same as a structure containing an integer.</p>

<h2 id="exercises-3">Exercises</h2>

<h3 id="map-function-with-interfaces" class="exercise" data-difficulty="2">Map function with interfaces</h3>

<ol>
<li>Use the answer from the earlier map exercise but now
make it generic using interfaces. Make it at least work for
ints and strings.</li>
</ol>

<h3 id="answer-14" class="answer">Answer</h3>

<ol>
<li></li>
</ol>

<pre><code class="language-go">package main

import &quot;fmt&quot;

// Define the empty interface as a type.
type e interface{}

func mult2(f e) e {
	switch f.(type) {
	case int:
		return f.(int) * 2
	case string:
		return f.(string) + f.(string) + f.(string) + f.(string)
	}
	return f
}

func Map(n []e, f func(e) e) []e {
	m := make([]e, len(n))
	for k, v := range n {
		m[k] = f(v)
	}
	return m
}

func main() {
	m := []e{1, 2, 3, 4}
	s := []e{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;}
	mf := Map(m, mult2)
	sf := Map(s, mult2)
	fmt.Printf(&quot;%v\n&quot;, mf)
	fmt.Printf(&quot;%v\n&quot;, sf)
}
</code></pre>

<h3 id="pointers" class="exercise" data-difficulty="1">Pointers</h3>

<ol>
<li><p>Suppose we have defined the following structure:</p>

<pre><code class="language-go">type Person struct {
    name string
    age	 int
}
</code></pre>
<p>What is the difference between the following two lines?</p>

<pre><code class="language-go">var p1 Person
p2 := new(Person)
</code></pre></li>

<li><p>What is the difference between the following two allocations?</p>

<pre><code class="language-go">func Set(t *T) {
    x = t
}
</code></pre>
<p>and</p>

<pre><code class="language-go">func Set(t T) {
    x= &amp;t
}
</code></pre></li>
</ol>

<h3 id="answer-15" class="answer">Answer</h3>

<ol>
<li><p>The expression, <code>var p1 Person</code> allocates a <code>Person</code>-<em>value</em> to <code>p1</code>. The type of <code>p1</code> is <code>Person</code>.
The second line: <code>p2 := new(Person)</code> allocates memory and assigns a <em>pointer</em> to <code>p2</code>. The type of <code>p2</code> is
<code>*Person</code>.</p></li>

<li><p>In the first function, <code>x</code> points to the same thing that <code>t</code> does, which is the same thing that the
actual argument points to. So in the second function, we have an &ldquo;extra&rdquo; variable containing a copy of the
interesting value. In the second function, <code>x</code> points to a new (heap-allocated) variable <code>t</code> which contains
a copy of whatever the actual argument value is.</p></li>
</ol>

<h3 id="linked-list" class="exercise" data-difficulty="1">Linked List</h3>

<ol>
<li><p>Make use of the package <code>container/list</code> to create
a (doubly) linked list. Push the values 1, 2 and 4 to the list and then
print it.</p></li>

<li><p>Create your own linked list implementation. And perform the same actions
as above.</p></li>
</ol>

<h3 id="answer-16" class="answer">Answer</h3>

<ol>
<li>The following is the implementation of a program using doubly
linked lists from <code>container/list</code>.</li>
</ol>

<pre><code class="language-go">package main

import (
	&quot;container/list&quot;
	&quot;fmt&quot;
)

func main() {
	l := list.New()
	l.PushBack(1)
	l.PushBack(2)
	l.PushBack(4)

	for e := l.Front(); e != nil; e = e.Next() {
		fmt.Printf(&quot;%v\n&quot;, e.Value)
	}
}
</code></pre>

<ol start="2">
<li>The following is a program implementing a simple doubly
linked list supporting <code>int</code> values.</li>
</ol>

<pre><code class="language-go">package main

import (
	&quot;errors&quot; <span class="callout">1</span>
	&quot;fmt&quot;
)

type Value int <span class="callout">2</span>

type Node struct { <span class="callout">3</span>
	Value
	prev, next *Node
}

type List struct {
	head, tail *Node
}

func (l *List) Front() *Node { <span class="callout">4</span>
	return l.head
}

func (n *Node) Next() *Node {
	return n.next
}

func (l *List) Push(v Value) *List {
	n := &amp;Node{Value: v} <span class="callout">5</span>

	if l.head == nil { <span class="callout">6</span>
		l.head = n
	} else {
		l.tail.next = n <span class="callout">7</span>
		n.prev = l.tail <span class="callout">8</span>
	}
	l.tail = n <span class="callout">9</span>

	return l
}

var errEmpty = errors.New(&quot;List is empty&quot;)

func (l *List) Pop() (v Value, err error) {
	if l.tail == nil { <span class="callout">10</span>
		err = errEmpty
	} else {
		v = l.tail.Value     <span class="callout">11</span>
		l.tail = l.tail.prev <span class="callout">12</span>
		if l.tail == nil {
			l.head = nil <span class="callout">13</span>
		}
	}

	return v, err
}

func main() {
	l := new(List)

	l.Push(1)
	l.Push(2)
	l.Push(4)

	for n := l.Front(); n != nil; n = n.Next() {
		fmt.Printf(&quot;%v\n&quot;, n.Value)
	}

	fmt.Println()

	for v, err := l.Pop(); err == nil; v, err = l.Pop() {
		fmt.Printf(&quot;%v\n&quot;, v)
	}
}
</code></pre>

<p>Import &lt;<span class="callout">1</span>&gt; the packages we will need. At &lt;<span class="callout">2</span>&gt; we declare a type for the value our list will contain,
this is not strictly neccesary. And at &lt;<span class="callout">3</span>&gt; we declare a type for the each node in our list.
At &lt;<span class="callout">4</span>&gt; we define the <code>Front</code> method for our list.
When pushing, create a new Node &lt;<span class="callout">5</span>&gt; with the provided value. If the list is empty &lt;<span class="callout">6</span>&gt;,
put the new node at the head. Otherwise &lt;<span class="callout">7</span>&gt; put it at the tail and make sure &lt;<span class="callout">8</span>&gt;
the new node points back to the previously existing one. At &lt;<span class="callout">9</span>&gt; we re-adjust tail
to the newly inserted node.</p>

<p>In the Pop <span class="callout">10</span> method, we return an error if the list is empty. If it is not empty <span class="callout">11</span>
we save the last value. And then <span class="callout">12</span> discard the last node from the list. Finally at <span class="callout">13</span>
we make sure the list is consistent if it becomes empty.</p>

<h3 id="cat" class="exercise" data-difficulty="1">Cat</h3>

<ol>
<li><p>Write a program which mimics the Unix program <code>cat</code>.</p></li>

<li><p>Make it support the <code>-n</code> flag, where each line is numbered.</p></li>

<li><p>The solution to the above question given in contains a bug. Can you spot and fix it?</p></li>
</ol>

<h3 id="answer-17" class="answer">Answer</h3>

<ol>
<li>The following is implemention of <code>cat</code> which also supports a -n flag to number each line.</li>
</ol>

<pre><code class="language-go">package main

import (
	&quot;bufio&quot;
	&quot;flag&quot;
	&quot;fmt&quot;
	&quot;io&quot; <span class="callout">1</span>
	&quot;os&quot;
)

var numberFlag = flag.Bool(&quot;n&quot;, false, &quot;number each line&quot;) // &lt;&lt;2&gt;&gt;

func cat(r *bufio.Reader) { <span class="callout">3</span>
	i := 1
	for {
		buf, e := r.ReadBytes('\n') <span class="callout">4</span>
		if e == io.EOF {            <span class="callout">5</span>
			break
		}
		if *numberFlag { <span class="callout">6</span>
			fmt.Fprintf(os.Stdout, &quot;%5d  %s&quot;, i, buf)
			i++
		} else { <span class="callout">7</span>
			fmt.Fprintf(os.Stdout, &quot;%s&quot;, buf)
		}
	}
	return
}

func main() {
	flag.Parse()
	if flag.NArg() == 0 {
		cat(bufio.NewReader(os.Stdin))
	}
	for i := 0; i &lt; flag.NArg(); i++ {
		f, e := os.Open(flag.Arg(i))
		if e != nil {
			fmt.Fprintf(os.Stderr, &quot;%s: error reading from %s: %s\n&quot;,
				os.Args[0], flag.Arg(i), e.Error())
			continue
		}
		cat(bufio.NewReader(f))
	}
}
</code></pre>

<p>At <span class="callout">1</span> we include all the packages we need.
 Here <span class="callout">2</span> we define a new flag &ldquo;n&rdquo;, which defaults to off. Note that we get the help (-h) for free.
 Start the function <span class="callout">3</span> that actually reads the file&rsquo;s contents and displays it;
 Read one line at the time at <span class="callout">4</span>. And stop <span class="callout">5</span> if we hit the end.
 If we should number each line, print the line number and then the line itself <span class="callout">6</span>.
 Otherwise <span class="callout">7</span> we could just print the line.</p>

<ol start="2">
<li>The bug show itself when the last line of the input does not
contain a newline. Or worse, when the input contains one line without a
closing newline nothing is shown at all. A better solution is the following
program.</li>
</ol>

<pre><code class="language-go">package main

import (
	&quot;bufio&quot;
	&quot;flag&quot;
	&quot;fmt&quot;
	&quot;io&quot;
	&quot;os&quot;
)

var numberFlag = flag.Bool(&quot;n&quot;, false, &quot;number each line&quot;)

func cat(r *bufio.Reader) {
	i := 1
	for {
		buf, e := r.ReadBytes('\n')
		if e == io.EOF &amp;&amp; string(buf) == &quot;&quot; {
			break
		}
		if *numberFlag {
			fmt.Fprintf(os.Stdout, &quot;%5d  %s&quot;, i, buf)
			i++
		} else {
			fmt.Fprintf(os.Stdout, &quot;%s&quot;, buf)
		}
	}
	return
}

func main() {
	flag.Parse()
	if flag.NArg() == 0 {
		cat(bufio.NewReader(os.Stdin))
	}
	for i := 0; i &lt; flag.NArg(); i++ {
		f, e := os.Open(flag.Arg(i))
		if e != nil {
			fmt.Fprintf(os.Stderr, &quot;%s: error reading from %s: %s\n&quot;,
				os.Args[0], flag.Arg(i), e.Error())
			continue
		}
		cat(bufio.NewReader(f))
	}
}
</code></pre>

<h3 id="method-calls" class="exercise" data-difficulty="2">Method calls</h3>

<ol>
<li><p>Suppose we have the following
program. Note the package <code>container/vector</code> was once part
of Go, but was removed when the <code>append</code> built-in was introduced.
However, for this question this isn&rsquo;t important. The package implemented
a stack-like structure, with push and pop methods.</p>

<pre><code class="language-go">package main


import &quot;container/vector&quot;


func main() {
    k1 := vector.IntVector{}
    k2 := &amp;vector.IntVector{}
    k3 := new(vector.IntVector)
    k1.Push(2)
    k2.Push(3)
    k3.Push(4)
}
</code></pre>
<p>What are the types of <code>k1</code>, <code>k2</code> and <code>k3</code>?</p></li>

<li><p>Now, this program compiles and runs OK. All the <code>Push</code>
operations work even though the variables are of a different type. The
documentation for <code>Push</code> says:</p>

<blockquote>
<p><code>func (p *IntVector) Push(x int)</code>
Push appends x to the end of the vector.</p>
</blockquote>

<p>So the receiver has to be of type <code>*IntVector</code>, why does the code
above (the Push statements) work correctly then?</p></li>
</ol>

<h3 id="answer-18" class="answer">Answer</h3>

<ol>
<li><p>The type of <code>k1</code> is <code>vector.IntVector</code>. Why? We use
a composite literal (the <code>{}</code>), so we get a value of that type
back. The variable <code>k2</code> is of <code>*vector.IntVector</code>, because we
take the address (<code>&amp;</code>) of the composite literal. And finally
<code>k3</code> has also the type <code>*vector.IntVector</code>, because <code>new</code>
returns a pointer to the type.</p></li>

<li><p>The answer is given in <cite class="informative"><a href="#go_spec"></a></cite> in the section &ldquo;Calls&rdquo;,
where among other things it says:</p></li>
</ol>

<blockquote>
<p>A method call <code>x.m()</code> is valid if the method set of (the type of)
<code>x</code>
contains <code>m</code> and the argument list can be assigned to the parameter list
of <code>m</code>. If <code>x</code> is addressable and <code>&amp;x</code>&rsquo;s method set
contains <code>m</code>, <code>x.m()</code> is shorthand for <code>(&amp;x).m()</code>.</p>
</blockquote>

<p>In other words because <code>k1</code> is addressable and
<code>*vector.IntVector</code> <em>does</em> have the <code>Push</code> method, the
call <code>k1.Push(2)</code> is translated by Go into
<code>(&amp;k1).Push(2)</code> which makes the type system happy again (and
you too &ndash; now you know this).<sup class="footnote-ref" id="fnref:Also-see-methods"><a href="#fn:Also-see-methods">14</a></sup></p>

<!--
# Interfaces
{{interfaces.md}}


# Concurrency
{{channels.md}}


# Communication
{{communication.md}}

-->

</section>
<section matter="back">
<div class="footnotes">

<hr>

<ol>
<li id="fn:Yes-that-sounds">Yes, that sounds a lot like *co*routines, but goroutines are slightly different as we will see in <a href="#communication"></a>.</li>

<li id="fn:http-play-golang"><a href="http://play.golang.org">http://play.golang.org</a>.</li>

<li id="fn:http-golang-org"><a href="http://golang.org/doc/">http://golang.org/doc/</a> itself is served by <code>godoc</code>.</li>

<li id="fn:When-building-fr">When building from source it must be installed separately with <code>go get golang.org/x/tools/cmd/godoc</code>.</li>

<li id="fn:The-word-iota-is">The word iota is used in a common English phrase, &lsquo;not one iota&rsquo;, meaning &lsquo;not the slightest difference&rsquo;, in reference to a phrase in the New Testament: &ldquo;<em>until heaven and earth pass away, not an iota, not a dot, will pass from the Law</em>.&rdquo; <cite class="informative"><a href="#iota"></a></cite></li>

<li id="fn:You-can-use-the">You can use the command <code>godoc builtin</code> to read the online documentation about the built-in types and functions.</li>

<li id="fn:Always-rainy-in">Always rainy in March anyway.</li>

<li id="fn:This-is-a-motto">This is a motto of Go; &ldquo;Do <em>more</em> with <em>less</em> code&rdquo;.</li>

<li id="fn:A-function-liter">A function literal is sometimes called a closure <span class="index" id="idxref:108"></span>.</li>

<li id="fn:Modified-from-a">Modified from a presentation of Eleanor McHugh.</li>

<li id="fn:The-descriptions">The descriptions are copied from the packages&rsquo; <code>go doc</code>.</li>

<li id="fn:The-downside-is">The downside is that you know have to worry about garbage collection. If you really need it garbage collection in a Go program can be disabled by running it with the environment variable <code>GOGC</code> set to <code>off</code>: <code>GOGC=off ./myprogram</code>.</li>

<li id="fn:Taking-the-addre">Taking the address of a composite literal tells the compiler to allocate it on the heap, not the stack.</li>

<li id="fn:Also-see-methods">Also see <a href="#methods"></a> in this chapter.</li>
</ol>

</div>
Normative References</section>

</body>
</html>

